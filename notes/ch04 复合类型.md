## 第四章 复合类型

### 4.1 数组

* 数组是一种数据格式，能够储存多个同类型的值：

  * 例如，数组可以储存60个int类型的值。
  * 创建数组时，需要如下声明：
    * 储存在每个元素中的值的类型；
    * 数组名；
    * 数组中的元素。
  * 声明数组的通用格式：
    * *typeName* arratName[arraySize];
    * short months[12];
    * 这里要`注意`：最后一个元素的索引比数组长度小1：
      * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/28300dd4-694f-48a2-850b-57f1af0da040)


* 例程：

  * ``` c++
    // arrayone.cpp -- small arrays of integers
    #include <iostream>
    int main() {
    	using namespace std;
    	int yams[3];
    	yams[0] = 7;
    	yams[1] = 8;
    	yams[2] = 6;
    
    	int yamcosts[3] = {20, 30, 5 };
    
    	cout << "Total yams = ";
    	cout << yams[0] + yams[1] + yams[2] << endl;
    	cout << "The package with " << yams[1] << " yams costs ";
    	cout << yamcosts[1] << " cents per yam.\n";
    	
    	int total = yams[0] * yamcosts[0] + yams[1] * yamcosts[1];
    	total = total + yams[2] * yamcosts[2];
    	cout << "The total yam expense is " << total << " cents.\n";
    
    	cout << "\nSize of yams array = " << sizeof yams;
    	cout << " bytes.\n";
    	cout << "Size of one element = " << sizeof yams[0];
    	cout << " bytes.\n";
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    Total yams = 21
    The package with 8 yams costs 30 cents per yam.
    The total yam expense is 410 cents.
    
    Size of yams array = 12 bytes.
    Size of one element = 4 bytes.
    ```

#### 4.1.1 程序说明

* 申明数组时，可以给数组元素赋值：

  * ``` c++
    int yamcosts[3] = {20, 30, 5 };
    ```

* sizeof运算符返回类型或数据对象的长度（单位为字节）：

  * 如果将 sizeof 用于数组名，得到的将是整个数组中的字节数。
  * 但如果将 sizeof 用于数组元素，则得到的将是元素的长度(单位为字节)。

#### 4.1.2 数组的初始化规则

* 只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组：

  * ``` c++
    int cards[4] = {3, 6, 8, 10};  //okay
    int hand[4];			      //okay
    hand[4] = {5, 6, 7, 9};		  //not allowed
    hand = cards;  				  //not allowed
    ```

* `但是`，可以使用下标分别给数组中的元素赋值。

* 初始化数组时，提供的值可以少于数组的元素数目。

* 如果只对数组的一部分进行初始化，则编译器将把其他元素设置为0。因此，将数组中所有的元素都初始化为0非常简单：

  * 只要显式地将第一个元素初始化为0,然后让编译器将其他元素都初始化为0即可:

  * ``` c++
    long cards[400] = {0};  //okay
    ```

* 如果初始化为{1}而不是{0}，则第一个元素被设置为1，其他元素都被设置为0。

* 如果初始化数组时方括号内([])为空，C++编译器将计算元素个数。例如，对于下面的声明:

  * ``` c++
    int cards[] = {3, 6, 8, 10};  //okay
    ```



#### 4.1.3 C++11数组初始化方法

* C++11将使用大括号的初始化（列表初始化）作为一种通用初始化方式，可用于所有类型。

* 新增功能：

  * 1、初始化数组时，可省略等号（=）：

    * ``` c++
      double earnings[4] {1.2e4, 1.6e4, 1.1e4, 1.7e4};
      ```

  * 2、可不在大括号内包含任何东西，这将把所有元素都设置为`零`：

    * ``` c++
      unsigned int counts[10] = {};
      float balances[100] {};
      ```

  * 3、列表初始化禁止缩窄转换,：

    * ``` c++
      long plifs[] = {25, 92, 3.0};  //将浮点数转换为整型是缩窄操作not allowed
      char slifs[4] = {'h', 'i', 1122011, '\0'};  //1122011超出了char变量的取值范围not allowed
      char tlifs[4] = {'h', 'i', 112, '\0'};  //因为虽然112是一个int值，但它在 char变量的取取值范围allowed
      ```



### 4.2 字符串

* C-风格字符串（需要又空字符（\0）结尾）-冗长乏味：

  * ```c++
    char cat[8] = {'f', 'a', 't', 'e', 's', 's', 'a', '\0'};
    ```

* 字符串常量/字符串字面值（更好的将字符数组初始化为字符串的方法）：

  * ``` c++
    char bird[11] = "Mr. Cheeps";
    char fish[] = "Bubbles";
    ```

  * 用引号括起的字符串隐式地包括结尾的空字符，因此不用显式地包括它。

* `注意`：字符串常量（使用双引号）不能与字符常量（使用单引号）互换。

  * 字符串常量（使用双引号）是字符串编码的简写表示：

    * ``` c++
      char shirt_size = 'S';//将83赋给shirt_size
      ```

  * "S"际上表示的是字符串所在的内存地址。因此下面的语句试图将一个内存地址赋给shirt_size:

    * ``` c++
      char shirt_size = "S";
      ```



#### 4.2.1 拼接字符串常量

* C++允许凭借字符串字面值，即将两个用引号括起的字符串合并为一个：

  * ``` c++
    cout << "I'd gibe my right arm to be" " a great violinist.\n";
    cout << "I'd gibe my right arm to be a great violinist.\n";
    cout << "I'd gibe my right ar"
        "m to be a great violinist.\n";
    ```

  * `注意`：拼接时不会在被连接的字符串之间添加空格，第二个字符串的第一个字符将紧跟在第一个字符串的最后一个字符（不考虑\0）后面。

  * 第一个字符串中的\0字符将被第二个字符串的第一个字符取代。



#### 4.2.2 在数组中使用字符串

* 将字符串储存到数组中的常用两大方法：

  * 1、将数组初始化为字符串常量。
  * 2、将键盘或文件输入读入到数组中。

* 例程：

  * ``` c++
    // strings.cpp -- storing strings in an array
    #include <iostream>
    #include <cstring>
    
    int main() {
    	using namespace std;
    	const int Size = 15;
    	char name1[Size];
    	char name2[Size] = "C++owboy";
    
    	cout << "Howdy! I'm " << name2;
    	cout << "! What's your name?\n";
    	cin >> name1;
    	cout << "Well, " << name1 << ", your name has ";
    	cout << strlen(name1) << " letters and is stored\n";
    	cout << "Your initial is " << name1[0] << ".\n";
    	name2[3] = '\0';
    	cout << "Here are the first 3 characters of my name: ";
    	cout << name2 << endl;
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    Howdy! I'm C++owboy! What's your name?
    Basicman
    Well, Basicman, your name has 8 letters and is stored
    Your initial is B.
    Here are the first 3 characters of my name: C++
    ```

  * sizeof运算符能够指出整个数组的长度；

  * 而strlen()函数能够返回储存在数组中的字符串长度（多少个可见字符，非空字符），而不是数组本身的长度（15字节）。

  * 将name2[3]设置为空字符，使得输出字符串在第三个字符后即结束。

    * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/a0c71cfc-6909-4842-af1b-18abf9541cec)




#### 4.2.3 字符串输入

* cin使用空白来确定字符串的结束位置，因此cin在获取字符数组输入时只读取一个单词。

* 例程：

  * ``` c++
    // instr1.cpp -- reading more than one string
    #include <iostream>
    
    int main() {
    	using namespace std;
    
    	const int ArSize = 20;
    	char name[ArSize];
    	char dessert[ArSize];
    
    	cout << "Enter your name:\n";
    	cin >> name;
    	cout << "Enter your favorite dessert:\n";
    	cin >> dessert;
    	cout << "I have some delicious " << dessert;
    	cout << " for you, " << name << ".\n";
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    Enter your name:
    Alistair Dreeb
    Enter your favorite dessert:
    I have some delicious Dreeb for you, Alistair.
    ```

* 解决办法：下届内容：采用面向行而不是面向单词的方法：



#### 4.2.4 每次读取一行字符串输入

* getline()：读取一行输入，丢弃换行符；

* get()：读取一行输入，将换行符保留在输入序列中。

* 1、getline()：

  * 调用方法：

    * cin.getline(name, 20);
    * 该函数有两个参数：
      * 第一个参数是用来存储输入行的数组的名称；
      * 第二个参数是要读取的字符数。如果这个参数为20，则函数最多读取19个字符，余下的空间用于存储自动在结尾处添加的`空字符`。
      * getline( )成员函数在读取指定数目的字符或遇到换行符时停止读取。

  * 例程：

    * ``` c++
      // instr2.cpp -- reading more than one word with getline
      #include <iostream>
      
      int main() {
      	using namespace std;
      
      	const int ArSize = 20;
      	char name[ArSize];
      	char dessert[ArSize];
      
      	cout << "Enter your name:\n";
      	cin.getline(name, ArSize);
      	cout << "Enter your favorite dessert:\n";
      	cin.getline(dessert, ArSize);
      	cout << "I have some delicious " << dessert;
      	cout << " for you, " << name << ".\n";
      	return 0;
      }
      ```

  * 结果：

    * ``` c++
      Enter your name:
      Dirk Hammernose
      Enter your favorite dessert:
      Radish Torte
      I have some delicious Radish Torte for you, Dirk Hammernose.
      ```

* 2、get()：

  * 由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符。

  * 因此get()认为已到达行尾，而没有发现任何可读取的内容。如果不借助于帮助，get()将不能跨过该换行符：

    * ``` c++ 
      cin.get(name, ArSize);
      cin.get(dessert, ArSize); //problem
      ```

  * 解决办法：

    * 1、使用不带任何参数的cin.get()调用：

      * ``` c++
        cin.get(name, ArSize);
        cin.get();
        cin.get(dessert, ArSize); 
        ```

    * 2、使用get()方式将两个类成员函数拼接：

      * ```c++
        cin.get(name, ArSize).get();
        cin.getline(name1, ArSize).getline(name2, ArSize);
        ```

  * 例程：

    * ``` c++
      // instr3.cpp -- reading more than one word with get() & get()
      #include <iostream>
      
      int main() {
      	using namespace std;
      
      	const int ArSize = 20;
      	char name[ArSize];
      	char dessert[ArSize];
      
      	cout << "Enter your name:\n";
      	cin.get(name, ArSize).get();
      	cout << "Enter your favorite dessert:\n";
      	cin.get(dessert, ArSize).get();
      	cout << "I have some delicious " << dessert;
      	cout << " for you, " << name << ".\n";
      	return 0;
      }
      ```

  * 结果：

    * ``` c++\
      Enter your name:
      Mai Parfait
      Enter your favorite dessert:
      Chocolate Mousse
      I have some delicious Chocolate Mousse for you, Mai Parfait.
      ```

  * 结论：getline()使用起来简单一些，但get()使得检查错误更简单些。

* 3、空行和其他问题：
  * 当get()读取空行后将设置失效位。即接下来的输入将被阻断，但可以用下面的命令来恢复输入：
    * cin.clear();
  * 输入字符串可能比分配的空间长：
    * getline()和get()将把余下的字符留在输入队列中；
    * 而getline()还会设置实效位，并关闭后面的输入。



#### 4.2.5 混合输入字符串和数字

* 例程：

  * ``` c++
    // numstr.cpp -- following number input with line input
    #include <iostream>
    
    int main() {
    	using namespace std;
    	cout << "What year was your house built?\n";
    	int year;
    	cin >> year;
    	cin.get();
    	cout << "What is its street address?\n";
    	char address[80];
    	cin.getline(address, 80);
    	cout << "Year built: " << year << endl;
    	cout << "Address: " << address << endl;
    	cout << "Done!\n";
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    What year was your house built?
    2000
    What is its street address?
    Beihang University
    Year built: 2000
    Address: Beihang University
    Done!
    ```

  * 如果不加cin.get()；代码就会把输入完数字后的回车转换为换行符留在输入队列中，当cin.getline()进行时，会认为换行符是空行，将空字符传给目标数组。



### 4.3 string类简介

* 可以用string类型的变量来储存字符串，而不是字符数组。

* string类更方便，同时提供了将字符串作为一种数据类型的表示方法。

* 例程：

  * ``` c++
    // strtype1.cpp -- using the C++ string class
    #include <iostream>
    #include <string>
    
    int main() {
    	using namespace std;
    	char charr1[20];
    	char charr2[20] = "jaguar";
    	string str1;
    	string str2 = "panther";
    
    	cout << "Enter a kind of feline: ";
    	cin >> charr1;
    	cout << "Enter another kind of feline: ";
    	cin >> str1;
    	
    	cout << "Here are some kind of felines:\n";
    	cout << charr1 << " " << charr2 << " "
    		 << str1 << " " << str2 << endl;
    	cout << "The third letter in " << charr2 << " is "
    		 << charr2[2] << endl;
    	cout << "The third letter in " << str2 << " is "
    		<< str2[2] << endl;
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    Enter a kind of feline: ocelot
    Enter another kind of feline: tiger
    Here are some kind of felines:
    ocelot jaguar tiger panther
    The third letter in jaguar is g
    The third letter in panther is n
    ```

  * 使用string对象的方式与使用字符数组基本相同；

  * 主要却别在于：

    * 可以将sting对象声明为简单变量，而不是数组：
      * string str1;
      * string str2 =  "panther";
    * 类设计能够让程序自动处理string的大小，使得与使用数组相比，更方便也更安全。



### 4.3 string类简介

* 可以用string类型的变量来储存字符串，而不是字符数组。

* string类更方便，同时提供了将字符串作为一种数据类型的表示方法。

* 例程：

  * ``` c++
    // strtype1.cpp -- using the C++ string class
    #include <iostream>
    #include <string>
    
    int main() {
    	using namespace std;
    	char charr1[20];
    	char charr2[20] = "jaguar";
    	string str1;
    	string str2 = "panther";
    
    	cout << "Enter a kind of feline: ";
    	cin >> charr1;
    	cout << "Enter another kind of feline: ";
    	cin >> str1;
    	
    	cout << "Here are some kind of felines:\n";
    	cout << charr1 << " " << charr2 << " "
    		 << str1 << " " << str2 << endl;
    	cout << "The third letter in " << charr2 << " is "
    		 << charr2[2] << endl;
    	cout << "The third letter in " << str2 << " is "
    		<< str2[2] << endl;
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    Enter a kind of feline: ocelot
    Enter another kind of feline: tiger
    Here are some kind of felines:
    ocelot jaguar tiger panther
    The third letter in jaguar is g
    The third letter in panther is n
    ```

  * 使用string对象的方式与使用字符数组基本相同；

  * 主要却别在于：

    * 可以将sting对象声明为简单变量，而不是数组：
      * string str1;
      * string str2 =  "panther";
    * 类设计能够让程序自动处理string的大小，使得与使用数组相比，更方便也更安全。



#### 4.3.1 C++11 字符串初始化

``` c++
char first_data[] = {"Le Chapon Dodu"};
char second_data[] {"Le Chapon Dodu"};
char third_data = {"Le Chapon Dodu"};
char fourth_data {"Le Chapon Dodu"};
```



#### 4.3.2 赋值、拼接和附加

* 1、赋值：

  * 可以将一个string对象赋给另一个string对象，但数组不能赋给另一个数组：

  * ```C++
    char charr1[20];
    char cahrr2[20] = "jaguar";
    string str1;
    string str2 = "panther";
    charr1 = charr2;//x INVALID
    str1 = str2;//VALID
    ```

* 2、拼接和附加：

  * 可以使用运算符+将两个string对象合并

  * 也可以用+=将字符串附加到string对象的末尾

  * ``` c++
    string str3;
    str3 = str1 + str2;
    str1 += str2;
    ```

* 例程：

  * ``` c++
    // strtype2.cpp -- assigning, adding, and appending
    #include <iostream>
    #include <string>
    int main() {
    	using namespace std;
    	string s1 = "penguin";
    	string s2, s3;
    
    	cout << "You can assign one string object to another: s2 = s1\n";
    	s2 = s1;
    	cout << "s1: " << s1 << ", s2: " << s2 << endl;
    	cout << "You can assign a C-style sring to a string object.\n";
    	cout << "s2 = \"buzzard\"\n";
    	s2 = "buzzard";
    	cout << "s2: " << s2 << endl;
    	cout << "You can concatenate strings: s3 = s1 + s2\n";
    	s3 = s1 + s2;
    	cout << "s3: " << s3 << endl;
    	cout << "You can cappend strings.\n";
    	s1 += s2;
    	cout << "s1 += s2 yields s1 = " << s1 << endl;
    	s2 += " for a day";
    	cout << "s2 += \" for a day\" yields s2 = " << s2 << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    You can assign one string object to another: s2 = s1
    s1: penguin, s2: penguin
    You can assign a C-style sring to a string object.
    s2 = "buzzard"
    s2: buzzard
    You can concatenate strings: s3 = s1 + s2
    s3: penguinbuzzard
    You can cappend strings.
    s1 += s2 yields s1 = penguinbuzzard
    s2 += " for a day" yields s2 = buzzard for a day
    ```



#### 4.3.3 string 类的其他类型

* 头文件cstring提供了给字符串赋值等工作的函数：

  * strcpy()将字符串赋值到字符数组中；
  * strcat()将字符串附加到字符数组末尾；

* 例程：

  * ``` c++
    // strtype3.cpp -- more string class features
    #define _CRT_SECURE_NO_WARNINGS
    #include <iostream>
    #include <string>
    #include <cstring>
    int main() {
    	using namespace std;
    	char charr1[20];
    	char charr2[20] = "jaguar";
    	string str1;
    	string str2 = "panther";
    
    	str1 = str2;
    	strcpy(charr1, charr2);
    
    	str1 += " paste";
    	strcat(charr1, " juice");
    
    	int len1 = str1.size();
    	int len2 = strlen(charr1);
    
    	cout << "The string " << str1 << " contains "
    		 << len1 << " characters.\n";
    	cout << "The string " << charr1 << " contains "
    		<< len2 << " characters.\n";
    
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    The string panther paste contains 13 characters.
    The string jaguar juice contains 12 characters.
    ```

  * 使用字符数组时，总是存在目标数目过小，无法储存指定信息的危险：

    * strcat()视图将全部字符复制到目标数组中，这将覆盖相邻的内存，可能导致程序终止。
    * 而string类具有自动调整大小的功能。

  * 确定字符串中字符数的方法：

    * ``` c++
      int len1 = str1.size();
      int len2 = strlen(charr1);
      ```

    * 而C++ string 类对象使用对象名和句点运算符来指出要使用哪个字符串。



#### 4.3.4 string 类 I/O

* 例程：

  * ``` c++
    // strtype4.cpp -- line input
    #include <iostream>
    #include <string>
    #include <cstring>
    
    int main() {
    	using namespace std;
    	char charr[20];
    	string str;
    
    	cout << "Length of string in charr before input: "
    		 << strlen(charr) << endl;
    	cout << "Length of string in str before input: "
    	   	 << str.size() << endl;
    	cout << "Enter a line of text:\n";
    	cin.getline(charr, 20);
    	cout << "You entered: " << charr << endl;
    	cout << "Enter another line of text:\n";
    	getline(cin, str);
    	cout << "You entered: " << str << endl;
    	cout << "Length of string in charr after input: "
    	 	 << strlen(charr) << endl;
    	cout << "Length of string in str after input: "
    		 << str.size() << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    Length of string in charr before input: 31
    Length of string in str before input: 0
    Enter a line of text:
    peanut butter
    You entered: peanut butter
    Enter another line of text:
    blueberry jam
    You entered: blueberry jam
    Length of string in charr after input: 13
    Length of string in str after input: 13
    ```

  * strlen()函数对于未被初始化的数据，第一个空字符出现的位置是随机的，因此得到的数组长度很可能与申明不同。

  * str.size()能够读取未被初始化的string对象长度，该长度自动这是为0；

  * cin.getline(charr, 20)：

    * getline是istream类的一个类方法；
    * cin是istream对象
    * （  ，）中第一个是目标数组，第二个是参数长度

  * getline(cin, str)：

    * 这里getline()不是类方法
    * 它将cin作为参数，指出到哪里去查找输入



#### 4.3.5 其他形式的字符串字面值

|   类型   | 前缀 |                  备注                   |
| :------: | :--: | :-------------------------------------: |
| wchar_t  |  L   | wchar_t title[] = L"Chief Astrogator";  |
| char16_t |  u   | char16_t name [] = u"Felonia Ripova" ;  |
| char32_t |  U   | char32_t car [] =U"Humber Super Snipe"; |
|   raw    |  R   |     cout << R"(xxx "xx" "\n"xxx)";      |

* 院士字符串语法语法允许再表示字符串开头的`"`和`(`之间添加其他字符

  * 使用R"+* (标识原始字符串的开头时，必须使用)+*标识原始字符串的

  * ```
    cout << R"+*("(Who wouldn't?)", she whispered.)+*" << endl;
    //out:"(Who wouldn't?)", she whispered.
    ```



### 4.4 结构简介

* 结构是一种比数组更灵活的数据格式，因为同一个结构可以储存多种类型的数据，这使得能够将有关篮球运动员的信息放在一个结构中，从而将数据的表示合并到一起。

* 结构的创建（2步）：

  * 1、定义结构描述：描述并标记了能够储存在结构中的各种数据类型；

    * ``` c++
      struct inflatable
      {
          char name[20];
          float volume;
          double price;
      };
      ```

    * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/d00c2ef2-ab79-4bff-8b76-c48aede396d6)


  * 2、按描述创建结构变量:

    * ``` c++
      inflatable hat;
      inflatable woopie_cushion;
      inflatable mainframe;
      ```

    * C++中创建结构变量可以省略struct。

    * 之后便可以使用hat.volume进行访问各个成员，hat是一个结构，而hat.volume是一个char变量。



#### 4.4.1 在程序中使用结构

* 例程：

  * ``` c++
    // structur.cpp -- a simple structure
    #include <iostream>
    struct inflatable {
    	char name[20];
    	float volume;
    	double price;
    };
    
    int main() {
    	using namespace std;
    
    	inflatable guest = {
    		"Glorious Gloria",
    		1.88,
    		29.99
    	};
    
    	inflatable pal = {
    		"Audacious Arthur",
    		3.12,
    		32.99
    	};
    
    	cout << "Expand your gest list with " << guest.name;
    	cout << " and " << pal.name << "!\n";
    	cout << "You can have both for $";
    	cout << guest.price + pal.price << "!\n";
    
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    Expand your gest list with Glorious Gloria and Audacious Arthur!
    You can have both for $62.98!
    ```

  * 结构声明这里采用外部声明，声明有两种方式，通常采用外部声明。

  * 变量也可以在函数内部和外部定义，这里提倡使用外部结构声明，内部变量定义。



#### 4.4.2 C++ 结构初始化

* 与数组一样，C++也支持将列表初始化用于结构，且等号是可选的：

  * ``` c++
    inflatable duck {"Daphne", 0.12, 9
                    98};
    ```

* 其次，如果大括号内未包含任何东西，各个成员都将被设置为零：

  * ```c++
    inflatable mayor {};
    ```

* 最后，不允许缩窄转换。



#### 4.4.3 结构可以将string类作为成员

* 只要您使用的编译器支持对以string对象作为成员的结构进行初始化，就可以。

* ``` c++
  #include <string>
  struct inflatable{
    std::string name;
    float volume;
    double price;
  };
  ```



#### 4.4.4 其他结构属性

* 1、可以将结构作为参数传递给函数，也可以让函数返回一个结构；

* 2、还可以使用赋值运算符（=）将结构赋给另一种类型的结构。

* 例程：

  * ```c++
    // assign_st -- assigning structures
    #include <iostream>
    struct inflatable{
    	char name[20];
    	float volume;
    	double price;
    };
    
    int main() {
    	using namespace std;
    	inflatable bouquet = {
    		"sunflowers",
    		0.20,
    		12.49
    	};
    
    	inflatable choice;
    	cout << "bouquet: " << bouquet.name << " for $";
    	cout << bouquet.price << endl;
    
    	choice = bouquet;
    	cout << "choice: " << choice.name << " for $";
    	cout << choice.price << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    bouquet: sunflowers for $12.49
    choice: sunflowersfor $12.49
    ```

  * 可以同时完成定义结构和创建结构变量的工作：

    * ``` c++
      struct perks
      {
          int key_number;
          char car[12];
      } mr_smith, ms_jones;
      
      //甚至可以初始化：
      struct perks
      {
          int key_number;
          char car[12];
      } mr_glitz = 
      {
          7,
          "Packard"
      };
      ```



#### 4.4.5 结构数组

* 可以创建元素为结构的数组：

  * ``` c++
    inflatable gifs[100];
    ```

  * 这样就就可以理解为创建了一批人，他们手上对应不同的物品

  * 即：gifts是一个inflatable数组，其中每个元素gifts[0]、gifts[1]都是inflatable对象，可以这样用：

    * gifts[0].volume;
    * gifts[99].price;

* 结构数组初始化：

  * ``` c++
    inflatable guests[2] = {
        {"Bambi", 0.5, 21.99},
        {"Godzilla", 2000, 565.99}
    };
    ```

* 例程：

  * ```c++
    // arrstruc.cpp -- an arry of structures
    #include <iostream>
    struct inflatable {
    	char name[20];
    	float volume;
    	double price;
    };
    
    int main() {
    	using namespace std;
    	inflatable guests[2] = {
    		{"Bambi", 0.5, 21.99},
    		{"Godzilla", 2000, 565.99}
    	};
    
    	cout << "The guests " << guests[0].name << " and " << guests[1].name
    		<< "\nhave a combined volume of "
    		<< guests[0].volume + guests[1].volume << " cubic feet.\n";
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    The guests Bambi and Godzilla
    have a combined volume of 2000.5 cubic feet.
    ```



#### 4.4.6 结构中的位字段

* C++也允许指定占用特定位数的结构成员：

* 字段的类型应为整型或枚举，接下来是冒号，冒号后面是一个数字，指定了使用的位数。

* 例程：

  * ``` c++
    struct torgle_register{
        unsigned int SN : 4;
        unsigned int : 4;
        bool goodIn : 1;
        bool goodTorgle : 1;
    }
    ```



### 4.5 共用体

* 共用体和结构体有相似之处，能够储存不同的数据类型，但是`只能同时储存其中的一种类型`。
* 由于共用体每次只能储存一个值，因此共用体的长度为其最大成员的长度。
* 用途之一：当数据项使用两种或更多种格式（但不会同时使用时），可以节省空间：
  * 例如管理一个小商品目录，其中有一些商品的ID为整数，而另一些ID为字符串。见P95，共用体用在了结构的成员当中，因此就说明了共用体是一种数据格式。
  * 共用体常用于(但并非只能用于）节省内存。当前，系统的内存多达数GB甚至数TB，好像没有必要节省内存，但并非所有的C++程序都是为这样的系统编写的。C++还用于嵌入式系统编程，如控制烤箱、MP3播放器或火星漫步者的处理器。对这些应用程序来说，内存可能非常宝贵。另外，共用体常用于操作系统数据结构或硬件数据结构。



### 4.6 枚举

* enum工具提供了另一种创建符号常量的方式，这种方式可以代替const。它还可以定义新类型，但必须按严格的限制进行：

  * ``` c++
    enum spectrum {red, orange, yellow, green, blue, violet, indigo, ultraviolet};
    ```

  * 让 spectrum成为新类型的名称；spectrum被称为枚举(enumeration)，就像struct变量被称为结构一样。

  * 将red、 orange、yellow等作为符号常量,它们对应整数值0~7。这些常量叫作枚举量( enumerator)。

  * 可以用枚举名来声明这种类型的变量：

    * ``` c++ 
      spectrum band;
      ```



#### 4.6.1 设置枚举量的值

* 可以使用赋值运算符来显式地设置枚举量的值：

  * ```c++
    enum bits{one = 1, two = 2, four = 4, eight = 8};
    ```

* 指定的值必须为整数。也可以只显式地定义其中一些枚举量的值：

  * ``` c++
    enum bigstep{first, second = 100, third};
    ```

  * 这里，first在默认情况下为0。后面没有被初始化的枚举量的值将比其前面的枚举量大1。即third=101。

* 可以创建多个值相同的枚举量：

  * ```c++
    enum {zero, null = 0, one, numero_uno = 1};
    ```



#### 4.6.2 枚举的取值范围

* 见P97



### 4.7 指针和自由存储空间

* 指针是一个变量，其储存的式值得地址，而不是值得本身。

* 对变量应用地址运算符即可找到常规变量得地址：

  * 例程：

    * ``` c++
      // address.cpp -- using the & operator to find addresses
      #include <iostream>
      
      int main() {
      	using namespace std;
      	int donuts = 6;
      	double cups = 4.5;
      
      	cout << "donuts value = " << donuts;
      	cout << " and donuts address = " << &donuts << endl;
      	cout << "cups value = " << cups;
      	cout << " and cups address = " << &cups << endl;
      
      	return 0;
      }
      ```

  * 结果：

    * ``` c++
      donuts value = 6 and donuts address = 00EFF6F4
      cups value = 4.5 and cups address = 00EFF6E4
      ```

* 指针名表示的是地址。*运算符可以得到该地址存储的值：

  * 例程：

    * ```c++
      // pointer.cpp -- our first pointer variable
      #include <iostream>
      int main() {
      	using namespace std;
      	int updates = 6;
      	int * p_updates;
      	p_updates = &updates;
      
      	cout << "Values: updates = " << updates;
      	cout << ", *p_updates = " << *p_updates << endl;
      
      	cout << "Addresses: &updates = " << &updates;
      	cout << ", p_updates = " << p_updates << endl;
      
      	*p_updates = *p_updates + 1;
      	cout << "Now updates = " << updates << endl;
      
      	return 0;
      }
      ```

  * 结果：

    * ```c++
      Values: updates = 6, *p_updates = 6
      Addresses: &updates = 00C4F884, p_updates = 00C4F884
      Now updates = 7
      ```

    * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/5b4687f0-f0ae-476a-9e97-bcfd28e291b2)




#### 4.7.1 声明和初始化指针

* 指针声明必须指定指针指向的数据类型：
  * int * p_updates;
  * p_updates的类型是指向int的指针

* 对于每个指针变量名，都需要使用一个*：

  * int* p1, p2;
  * 该声明创建了一个指针（p1）和一个int变量（p2）

* 例程：

  * ``` c++
    //int_ptr.cpp -- initialize a pointer
    #include <iostream>
    int main() {
    	using namespace std;
    	int higgens = 5;
    	int* pt = &higgens;
    
    	cout << "Value of higgens = " << higgens
    		 << "; Address of higgens = " << &higgens << endl;
    	cout << "Value of *pt = " << *pt
    		 << "; Address of pt = " << pt << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    Value of higgens = 5; Address of higgens = 008FF954
    Value of *pt = 5; Address of pt = 008FF954
    ```

  * 程序将pi（而不是*pi）初始化为higgens的地址：

    * ``` c++
      int* pt = &higgens;
      ```

    * 等价于：

    * ``` c++
      	int * pt;
      	pt = &higgens;
      ```



#### 4.7.2 指针的危险

* 在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向数据内存。



#### 4.7.3 指针和数字

* 指针不是数字，不能简单地将整数赋值给指针，需要强制转换：

* ``` c++
  int* pt;
  pt - (int *) 0xB8000000;
  ```



#### 4.7.4 使用new来分配内存

* ```c++
  int* pn = new int;
  ```

  * new int 告诉程序，需要适合存储int的内存，new运算符根据类型来确定需要多少字节的内存。
  * 然后找到这样的内存，并返回该内存块的地址。

* 为一个数据对象（可以是结构，也可以是基本类型）获得并指定分配内存的通用格式如下:

  * ```c++
    typeName* pointer_name = new typeName;
    ```

* 例程：

  * ```c++
    // use_new.cpp -- using the new operator
    #include <iostream>
    
    int main() {
    	using namespace std;
    	int nights = 1001;
    	int* pt = new int;
    	*pt = 1001;
    	
    	cout << "nights value = ";
    	cout << nights << ": location " << &nights << endl;
    	cout << "int ";
    	cout << "value = " << *pt << ": location = " << pt << endl;
    	double* pd = new double;
    	*pd = 10000001.0;
    
    	cout << "double ";
    	cout << "value = " << *pd << ": location = " << pd << endl;
    	cout << "location of pointer pd: " << &pd << endl;
    	cout << "size of pt = " << sizeof(pt);
    	cout << ": size of *pt = " << sizeof(*pt) << endl;
    	cout << "size of pd = " << sizeof(pd);
    	cout << ": size of *pd = " << sizeof(*pd) << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    nights value = 1001: location 00B9FC44
    int value = 1001: location = 01220B98
    double value = 1e+07: location = 01221B80
    location of pointer pd: 00B9FC2C
    size of pt = 4: size of *pt = 4
    size of pd = 4: size of *pd = 8
    ```



#### 4.7.5 使用delete释放内存

* 当需要内存时，可以使用new来请求；

* 当使用完内存后，需要将其归还给内存池时，可以使用delete运算符。

  * ``` c++
    int* ps = new int;
    ...
    delete ps;
    ```

  * 这将释放ps指向的内存，但不会删除指针ps 本身。例如，可以将ps重新指向另一个新分配的内存块。

* `注意`：详情见P104

  * 一定要配对地使用new和delete；
  * 不要尝试释放已经释放地内存块；
  * 不能使用delete来释放声明变量所获得的内存。



#### 4.7.6 使用new来创建动态数组

* 应用于大型数据，使用new时，如果在运行阶段需要数组，则创建它。

* 1、使用new 创建动态数组：

  * 只要将数组的元素类型和元素数目告诉new即可：

    * ``` C++
      int* psome = new int [10];
      ```

    * new运算符返回第一个元素的地址。

  * 当使用完new分配的内存块时，应使用delete释放他们，对`对应`的释放方式为：

    * ``` c++
      delete [] psome;
      ```

  * 总结，使用new和delete时，应遵守如下规则：

    * 不要使用delete来释放不是new分配的内存。
    * 不要使用delete释放同一个内存块两次。
    * 如果使用new []为数组分配内存，则应使用delete []来释放。
    * 如果使用new []为一个实体分配内存，则应使用delete（没有方括号）来释放。
    * 对空指针应用delete是安全的。

  * 不能使用sizeof运算符来确定动态分配的数组包含的字节数。

  * 为数组分配内存的通用格式：

    * ``` c++
      type_name * pointer_name = new type_name [num_elements]
      ```

* 2、使用动态数组

  * ```c++
    int* psome = new int [10];
    ```

  * 只要把指针当作数组名使用即可：

    * 第一个元素psome[0]，第二个元素psome[1]

  * 例程：

    * ``` c++
      // arraynew.cpp -- using the new operator for arrays
      #include <iostream>
      int main() {
      	using namespace std;
      	double* p3 = new double[3];
      	p3[0] = 0.2;
      	p3[1] = 0.5;
      	p3[2] = 0.8;
      	cout << "p3[1] is " << p3[1] << ".\n";
      	p3 = p3 + 1;
      	cout << "Now p3[0] is " << p3[0] << " and ";
      	cout << "p3[1] is " << p3[1] << ".\n";
      	p3 = p3 - 1;
      	delete [] p3;
      	
      	return 0;
      }
      ```

  * 结果：

    * ``` c++
      p3[1] is 0.5.
      Now p3[0] is 0.5 and p3[1] is 0.8.
      ```

  * 相邻的 int 地址通常相差2个字节或4个字节，而将p3加1后，它将指向下一个元素的地址，这表明指针算术有一些特别的地方。详情见P106



### 4.8 指针、数组和指针算术

#### 4.8.1 示例

* 示例：

  * ```c++
    // addpntrs.cpp -- pointer addition
    #include <iostream>
    int main() {
    	using namespace std;
    	double wages[3] = {10000.0, 20000.0, 30000.0 };
    	short stacks[3] = {3, 2, 1 };
    
    	double * pw = wages;
    	short * ps = &stacks[0];
    
    	cout << "pw = " << pw << ", *pw = " << *pw << endl;
    	pw = pw + 1;
    	cout << "add 1 to the pw pointer:\n";
    	cout << "pw = " << pw << ", *pw = " << *pw << "\n\n";
    
    	cout << "ps = " << ps << ", *ps = " << *ps << endl;
    	ps = ps + 1;
    	cout << "add 1 to the ps pointer:\n";
    	cout << "ps = " << ps << ", *ps = " << *ps << "\n\n";
    
    	cout << "access two elements with array notation\n";
    	cout << "stacks[0] = " << stacks[0]
    		 << ", stacks[1] = " << stacks[1] << endl;
    	
    	cout << "access two elements with pointer notation\n";
    	cout << "*stacks = " << *stacks
    		<< ", *(stacks + 1) = " << *(stacks + 1) << endl;
    
    	cout << sizeof(wages) << " = size of wages array\n";
    	cout << sizeof(pw) << " = size of pw pointer\n";
    
    	return 0;
    }
    ```

* 结果：

  * ``` c++
    pw = 004FFD08, *pw = 10000
    add 1 to the pw pointer:
    pw = 004FFD10, *pw = 20000
    
    ps = 004FFCF8, *ps = 3
    add 1 to the ps pointer:
    ps = 004FFCFA, *ps = 2
    
    access two elements with array notation
    stacks[0] = 3, stacks[1] = 2
    access two elements with pointer notation
    *stacks = 3, *(stacks + 1) = 2
    24 = size of wages array
    4 = size of pw pointer
    ```

  * C++将数组名解释为数组第一个元素的地址：

    * wages = &wages[0] = address of first element of array

  * 将指针变量加1后，其增加的值等于指向的类型占用的字节数。

  * 使用数组表示法，可执行如下转换：

    * arrayname [i] becomes *(arrayname + i)

  * 如果使用的是指针，而不是数组名，则：

    * pointername [i] becomes *(pointername + i)

  * 区别：

    * 1、解除引用运算符（*）时，它们都表示指针，但是可以修改指针的值，而不能修改数组名的值，因为数组名是常量。
    * 2、对数组应用sizeof得到的是数组的长度（所有数据的位宽），而对指针应用sizeof得到的是指针的长度（地址的位宽）。



#### 4.8.2 指针小结

* 1、声明指针

  * 通用格式：

    * ``` c++
      typeName * pointerName;
      ```

* 2、给指针赋值

  * 应将内存地址赋值给指针：

    * 可以对变量名应用&运算符，来获得被命名的内存地址：

      * ``` c++
        double * pn;
        double bubble = 3.2;
        pn = &bubble;
        ```

    * new运算符返回未命名的内存地址：

      * ```c++
        double * pa;
        char * pc;
        pc = new char;
        pa = new double[30];
        ```

* 3、对指针解除引用

  * 对指针解除引用意味着获得指针指向的值。

  * 对指针应用解除引用或间接值运算符（*）来解除引用：

    * ```c++
      cout << *pn;
      *pc = 's';
      ```

* 4、区分指针和指针所指向的值

  * 如果pt是指向int的指针，则*pt完全等同于一个int类型的变量。（pt才是指针）

* 5、数组名

  * 多数情况下：C++将数组名视为数组的第一个元素的地址。
  * 例外：sizeof数组名时，返回整个数组的位宽长度。

* 6、指针算术

  * C++允许将指针和整数相加，加1的结果等于原来的地址值加上指向的对象占用的总字节数。
  * 还可以将一个指针减去另一个指针，获得两个指针的差（整数，仅当两个指针指向同一个数组时才有意义）

* 7、数组的动态联编和静态联编

  * 静态联编：

    * 使用数组声明来创建数组时，采用的是静态联编，即数组的长度在编译时设置：

      * ```c++
        int tacos[10];
        ```

  * 动态联编：

    * 使用new[]运算符创建数组时，采用的是动态联编，即将在运行时为数组分配空间，其长度将在运行时设置。使用完成这种数组后，应使用delete[]释放其占用的内存。

      * ``` c++
        int size;
        cin >> size;
        int* pz = new int [size];
        ...
        delete [] pz;
        ```

* 8、数组表示法和指针表示法（`难懂`）

  * 使用方括号数组表示法等同于对指针解除引用(你可以理解为解除引用就是表示指针指向地址的值)

    * ```c++
      tacos[0] means *tacos means the value at address tacos;
      tacos[3] means *(tacos + 3) means the value at address tacos + 3
      ```

  * 对于指针和数组名，既可以使用指针表示法，也可以使用数组表示法：

    * ```c++
      int* pt = new int [10];
      *pt = 5;			//set element number 0 to 5;
      pt[0] = 6;			//reset element number 0 to 6
      pt[9] = 44;  		//set tenth element(element number 9) to 44
      int coats[10];
      *(coats + 4) = 12  	//set coats[4] to 12
      ```



#### 4.8.3 指针和字符串

* 在cout和多数C++表达式中，char数组名、char指针以及用引号括起的字符串常量都被解释为字符串第一个字符的地址；

* 例程：

  * ```c++
    // ptrstr.cpp -- using pointers to strings
    #define _CRT_SECURE_NO_WARNINGS
    #include <iostream>
    #include <cstring>
    
    int main() {
    	using namespace std;
    	char animal[20] = "bear";
    	const char* bird = "wren";	//bird holds address of string
    	char* ps;
    
    	cout << animal << " and ";
    	cout << bird << "\n";
    
    	cout << "Enter a kind of animal: ";
    	cin >> animal;
    
    	ps = animal;
    	cout << ps << "!\n";
    	cout << "Before using strcpy():\n";
    	cout << animal << " at " << (int*) animal << endl;
    	cout << ps << " at " << (int *) ps << endl;
    
    	ps = new char[strlen(animal) + 1];
    	strcpy(ps, animal);
    	cout << "After using strcpy():\n";
    	cout << animal << " at " << (int*)animal << endl;
    	cout << ps << " at " << (int*)ps << endl;
    	delete [] ps;
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    bear and wren
    Enter a kind of animal: fox
    fox!
    Before using strcpy():
    fox at 0079FA98
    fox at 0079FA98
    After using strcpy():
    fox at 0079FA98
    fox at 00E5C7A8
    ```

  * "wren"实际表示的时字符串的地址，因此const char* bird = "wren";将“wren”的地址赋值给了bird指针。

  * 字符串字面值是常量，所以声明中使用const，可以用bird来访问字符串，但是不能修改它。

  * 对于cout来说，使用数组名animal和指针bird是一样的，它们都是字符串的地址，cout将显示储存在这两个地址上的两个字符串。

  * 使用const char* bird来输入并不合适：

    * 有些编译器将字符串字面值视为只读常量，如果试图修改它们，将导致运行阶段错误。在C++中，字符串字面值都将被视为常量，但并不是所有的编译器都对以前的行为做了这样的修改。
    * 有些编译器只使用字符串字面值的一个副本来表示程序中所有的该字面值。

  * 总结：

    * 不要使用字符串常量或未被初始化的指针来接收输入。

  * 警告：

    * 在将字符串读入程序时，应使用已分配的内存地址。该地址可以是数组名，也可以是使用new初始化过的指针。

  * 你不懂的部分：

    * ``` c++
      	ps = animal;
      	cout << animal << " at " << (int*) animal << endl;
      	cout << ps << " at " << (int *) ps << endl;
      
      //////////////out//////////////
      fox at 0079FA98
      fox at 0079FA98
      ```

    * 如果给cout提供一个地址，他将打印储存在地址上的内容；

    * 如果给cout提供一个指针，它将打印地址；

      * 如果指针的类型为char *，则cout将显示指向的字符串；所以要显示字符串的地址，需要强制转换指针为int *

      * 即：

        * ``` c++
          cout << ps; //display fox
          cout << (int*) ps; //display address of 'fox'
          ```

    * ```c++
      ps = animal;
      ```

      * 将animal赋值给ps，并不会赋值字符串，而只赋值地址，表示两个指针同时指向相同内存单元的字符串。

    * 要获得字符串副本：

      * 1、声明另一个数字

      * 2、使用new：

        * ``` c++
          ps = new char[strlen(animal) + 1];
          ```

        * fox不能填满整个animal，因此为了节省内存空间，使用strlen()确定字符串的长度；

        * strlen(animal) + 1 表示获得包含fox和空字符的长度，然后用new来分配空间。

    * 复制字符串：

      * ```c++
        strcpy(ps, animal);
        ```

      * strcpy()接受2个参数：

        * 第一个是目标地址；
        * 第二个是要复制的字符串的地址。

    * 将字符串赋给数组：

      * 初始化数组时，请使用=运算符；否则应使用 strcpy()或strncpy()。
      * 其他时候应使用strcpy()或strncpy()，而不是赋值运算符来将字符串赋给数组。



#### 4.8.4 使用new创建动态结构

* 📌在运行时创建数组优于在编译时创建数组，对于结构也是如此。

* 将new用于结构由2步组成：

  * 1、创建结构

    * ```c++
      inflatable * ps = new inflatable;
      ```

      * 结构中的指针应用：

        * 方法1：

          * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/caa27939-0055-4cfd-ac20-15d3a4e7db44)

          * 如果结构标识符是结构名，则使用句点运算符；
          * 如果标识符是指向结构的指针，则使用箭头运算符。

        * 方法2：

          * 如果ps是指向结构的指针，则*ps就是被指向的值——结构本身。
          * 由于* ps是一个结构，因此(* ps) .price是该结构的price成员。C++的运算符优先规则要求使用括号。

        * 例程：

          * ```c++
            // newstrct.cpp -- using new with a stucture
            #include <iostream>
            struct inflatable {
            	char name[20];
            	float volume;
            	double price;
            };
            
            int main() {
            	using namespace std;
            	inflatable* ps = new inflatable;
            	cout << "Enter name of inflatable item: ";
            	cin.get(ps->name, 20);
            	cout << "Enter volume in cubic feet: ";
            	cin >> (*ps).volume;
            	cout << "Enter price: $";
            	cin >> ps->price;
            	cout << "Name: " << (*ps).name << endl;
            	cout << "Volume: " << ps->volume << " cubic feet\n";
            	cout << "Price: $" << ps->price << endl;
            	delete ps;
            
            	return 0;
            }
            ```

        * 结果：

          * ``` c++
            Enter name of inflatable item: Fabulous Frodo
            Enter volume in cubic feet: 1.4
            Enter price: $27.99
            Name: Fabulous Frodo
            Volume: 1.4 cubic feet
            Price: $27.99
            ```

  * 2、访问其成员

* 一个使用new和delete的示例：

  * ```c++
    // delete.cpp -- using the delete operator
    #define _CRT_SECURE_NO_WARNINGS
    #include <iostream>
    #include <cstring>
    
    using namespace std;
    char* getname(void);
    
    int main() {
    	char* name;
    
    	name = getname();
    	cout << name << " at " << (int*)name << "\n";
    	delete [] name;
    
    	name = getname();
    	cout << name << " at " << (int*)name << "\n";
    	delete[] name;
    	return 0;
    }
    
    char* getname() {
    	char temp[80];
    	cout << "Enter last name: ";
    	cin >> temp;
    	char* pn = new char[strlen(temp) + 1];
    	strcpy(pn, temp);
    
    	return pn;
    }
    ```

* 结果：

  * ``` c++
    Enter last name: Fredeldumpkin
    Fredeldumpkin at 013609F0
    Enter last name: Pook
    Pook at 013618F8
    ```

  * 在这个例子中，getname()分配内存，而main()释放内存。将 new 和 delete 放在不同的函数中通常并不是个好办法，因为这样很容易忘记使用delete。不过这个例子确实把 new 和 delete 分开放置了，只是为了说明这样做也是可以的。



#### 4.8.5 自动存储、静态存储和动态存储

* 1、自动存储
  * 在函数内部定义的常规变量使用自动存储空间，被称为自动变量(automatic variable)，这意味着它们在所属的函数被调用时自动产生,在该函数结束时消亡。
  * 自动变量是一个局部变量，其作用域为包含它的代码块。
  * 自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为后进先出（LIFO)。因此，在程序执行过程中，栈将不断地增大和缩小。
* 2、静态存储
  * 静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种；
    * 一种是在函数外面定义它；
    * 另一种是在声明变量时使用关键字static。
* 3、动态存储
  * new和delete运算符提供了一种比自动变量和静态变量更灵活的方法：
    * 它们管理了一个内存池，这在C++中被称为自由存储空间(free store)或堆(heap)。
    * 该内存池同用于静态变量和自动变量的内存是分开的。new和delete让您能够在一个函数中分配内存，而在另一个函数中释放它。因此，数据的生命周期不完全受程序或函数的生存时间控制。
  * 要避免内存泄漏需要同时使用new和delete运算符，在自由存储空间上动态分配内存，随后便释放它。



### 4.9 类型组合

* `很难懂`，<u>**想办法找点视频看一下**</u>。P118-119

* ``` c++
  struct antarctica_years_end{
    int year;
  };
  
  antarctica_years_end s01, s02, s03;
  s01.year = 1998;
  const antarctica_years_end* arp[3] = {&s01, &s02, &s03}//arp是一个指针数组，arp[1]就是一个指针
  std::cout << arp[1]->year << std::cout;
  const antarctica_years_end** ppa = arp;//arp是一个指针数组，作为数组名，是第一个元素的地址。而第一个元素是指针，所以ppa=arp是一个指针
  auto ppb = arp;
  std::cout << (*ppa)->year << std::endl;//ppa是一个指向结构指针的指针，所以*ppa是一个结构指针，即(*ppa)等价于arp[0]中的值&s01
  std::cout << (*(ppb+1))->year << std::endl;
  ```

* ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/e6122953-e96f-4a1d-b6ed-f03ccb77241e)


* 例程：

  * ```c++
    // mixtypes.cpp -- some type combinations
    #include <iostream>
    
    struct antarctica_years_end {
    	int year;
    };
    
    int main() {
    	antarctica_years_end s01, s02, s03;
    	s01.year = 1998;
    	antarctica_years_end* pa = &s02;
    	pa->year = 1999;
    	//trio是一个数组，trio[0]是一个结构，而trio[0].year是该结构的一个成员
    	antarctica_years_end trio[3];
    	trio[0].year = 2003;
    	//数组名是一个指针，因此可以使用间接陈冠符号：
    	std::cout << trio->year << std::endl;
    	//定义一个指针数组，arp[1]等价于&s02，即指向s02的指针
    	const antarctica_years_end* arp[3] = {&s01, &s02, &s03};
    	std::cout << arp[1]->year << std::endl;
    	//arp是指针数组的数组名，代表第一个元素的地址
    	const antarctica_years_end** ppa = arp;
    	auto ppd = arp;
    	//ppa=arp说明ppa指向了第一元素，第一个元素是s01的结构指针&s01
    	//因此ppa是指向结构指针的指针，那么*ppa等价于第一个元素&s01
    	std::cout << (*ppa)->year << std::endl;
    	std::cout << (*(ppd+1))->year << std::endl;
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    2003//trio[0].year
    1999//s02
    1998//s01
    1999//s02
    ```



### 4.10 数组的替代品

#### 4.10.1 模板类vector

* 模板类vector类似于string类，也是一种动态数组；
  * 可以在运行阶段设置vector对象的长度，可在末尾附加新数据，还可在中间插入新数据。
  * 它是使用new创建动态数组的替代品。
* 如何使用vector对象：
  * 1、必须包含头文件：
    * #include <vector>
  * 2、vector包含在名称空间std中，因此可以使用using编译指令、using声明或std::vector：
    * using namespace std;
  * 3、模板使用不同的语法来指出它存储的数据类型：
    * vector<int> vi;
  * 4、vector类使用不同的语法来指定元素数：
    * int n;
    * cin >> n;
    * vector<double> vd(n);
* 📌声明创建一个名为vt的vector对象通用格式：
  * vector<*typeName*> vt(*n_elem*);
  * n_elem可以是整型常量，也可以是整型变量。



#### 4.10.2 模板类array（C++11）

* vector类的功能比数组强大，但付出的代价是效率稍低。如果需要长度固定的数组可以使用数组，更好的办法是使用模板类array，其长度也是固定的，使用栈，效率与数组相同，会更加方便安全。
* 创建方法：
  * 1、必须包含头文件：
    * #include <array>
  * 2、vector包含在名称空间std中，因此可以使用using编译指令、using声明或std::vector：
    * using namespace std;
  * 3、模板使用不同的语法来指出它存储的数据类型：
    * array<int, 5> ai;
    * array<double, 4> = {1.2, 2.1, 3.43, 4.3}
* 📌声明创建一个名为arr的array对象通用格式：
  * array<*typeName， n_elem*> arr;
  * n_elem可以是整型常量，`不能`是整型变量。



#### 4.10.3 比较数组、vector对象和array对象

* 示例：

  * ```c++
    #include <array>
    
    int main() {
    	using namespace std;
    	double a1[4] = { 1.2, 2.4, 3.6, 4.8};
    	vector<double> a2(4);
    	a2[0] = 1.0/3.0;
    	a2[1] = 1.0/5.0;
    	a2[2] = 1.0/7.0;
    	a2[3] = 1.0/9.0;
    
    	array<double, 4> a3 = { 3.14, 2.72, 1.62, 1.41 };
    	array<double, 4> a4;
    	a4 = a3;
    
    	cout << "a1[2]: " << a1[2] << " at " << &a1[2] << endl;
    	cout << "a2[2]: " << a2[2] << " at " << &a2[2] << endl;
    	cout << "a3[2]: " << a3[2] << " at " << &a3[2] << endl;
    	cout << "a4[2]: " << a4[2] << " at " << &a4[2] << endl;
    
    	a1[-2] = 20.2;
    	cout << "a1[-2]: " << a1[-2] << " at " << &a1[-2] << endl;
    	cout << "a3[2]: " << a3[2] << " at " << &a3[2] << endl;
    	cout << "a4[2]: " << a4[2] << " at " << &a4[2] << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    a1[2]: 3.6 at 00AFF738
    a2[2]: 0.142857 at 0101C878
    a3[2]: 1.62 at 00AFF6F8
    a4[2]: 1.62 at 00AFF6D0
    a1[-2]: 20.2 at 00AFF718
    a3[2]: 1.62 at 00AFF6F8
    a4[2]: 1.62 at 00AFF6D0
    ```

  * ``` c++
    a1[-2] = 20.2;
    //等价于：
    *(a1-2) = 20.2;
    ```

    * 找到a1指向的地方，向前移两个double元素，并将20.2存储到目的地。也就是说，将信息存储到数组的外面。与C语言一样，C++也不检查这种超界错误。

    * 禁止这种行为取决于你！

    * 其他选择：使用成员函数at():

      * a2.at(1) = 2.3;//assign 2.3 to a2[1]

      

