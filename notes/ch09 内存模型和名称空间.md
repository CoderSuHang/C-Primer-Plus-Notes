## 第九章 内存模型和名称空间

### 9.1 单独编译

* 1、C++允许将组件函数放在独立的文件中。

* 2、原来在一个文件内编写程序时，将支持函数放在main()函数之后。如果将原来文件分为两个，但是main()函数和支持函数使用了同一个数据结构声明。因此将一个程序放在多个文件中将引出新的问题：

  * 解决办法：使用“#include”来处理这种情况，将结构声明放在头文件中，然后在每个源代码文件中都包含该头文件。
  * 这样要修改结构声明时，只需在头文件中做一次改动即可。
  * 另外，也可以将函数原型放在头文件中。
  * 因此，可将原来的程序分为三部分：
    * 头文件：包含结构声明和使用这些结构的函数的原型；
    * 源代码文件：包含与结构有关的函数的代码；
    * 源代码文件：包含调用与结构相关的函数的代码。

* 3、📌不要将**函数定义**或**变量声明**放到头文件中。头文件中常包含的内容：

  * 函数原型。
  * 使用#define或const定义的符号常量。
  * 结构声明。
  * 类声明。
  * 模板声明。
  * 内联函数。

* 4、示例：

  * 程序清单09_01，程序清单09_02，程序清单09_03是将清单07_12分成个独部后得到的结果。

  * 在包含头文件时，使用“coordin.h”而不是<coordin.h>。

    * 如果文件名包含在尖括号中，则C++编译器将在储存标准头文件的主机系统的文件系统中查找；
    * 但如果文件名包含在双引号中，则C++编译器将首先查找当前的工作目录或源代码目录。如果没有找到，则将在标准的位置查找。
    * 因此在包含**自己**的头文件时，使用双引号。

  * 图9.1简要地说明了在UNIX 系统中将该程序组合起来的步骤：

    * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/6e114ad2-e50d-40ff-8eda-a6122e3d6ef6)


  * 警告：在IDE中，不要将头文件加入到项目列表中，也不要在源代码文件中使用#imclude 来包含其他源代码文件。

  * ```c++
    // ch09_01_coordin.h -- structyre templates and function prototypes
    // structure templates
    
    #ifndef COORDIN_H_
    #define COORDIN_H_
    
    struct polar {
    	double distance;
    	double angle;
    };
    
    struct rect {
    	double x;
    	double y;
    };
    
    // prototypes
    polar rect_to_polar(rect xypos);
    void show_polar(polar dapos);
    
    #endif
    ```

    * 仅当以前没有使用预处理编译指令#define定义名称COORDIN_H_时，才处理 #ifndef 和 #endif 之间的语句：

      * ```c++
        #ifndef COORDIN_H_
        ...
        #endif
        ```

    * 通常，使用 #define 语句来创建符号常量，如下所示：

      * ```c++
        #define MAXIMUM 4096
        ```

    * 但只要将 #define 用于名称，就足以完成该名称的定义：

      * ```c++
        #define COORDIN_H_
        ```

    * 程序清单09_01使用这种技术是为了将头文件内容包含在 #ifndef中：

      * ```c++
        #ifndef COORDIN_H_
        #define COORDIN_H_
        // place include file contents here
        #endif
        ```

  * ```c++
    // ch09_02_file1.cpp -- example of a three-file program
    #include<iostream>
    #include"coordin.h"
    using namespace std;
    int main() {
    	rect rplace;
    	polar pplace;
    
    	cout << "Enter the x and y values: ";
    	while (cin >> rplace.x >> rplace.y) {
    		pplace = rect_to_polar(rplace);
    		show_polar(pplace);
    		cout << "Next two numbers <q to quit>: ";
    	}
    	cout << "Bye!\n";
    	return 0;
    }
    ```

  * ```c++
    // ch09_03_file2.cpp -- contains functions called in file1.cpp
    #include<iostream>
    #include<cmath>
    #include"coordin.h"
    
    polar rect_to_polar(rect xypos) {
    	using namespace std;
    	polar answer;
    
    	answer.distance =
    		sqrt(xypos.x * xypos.x + xypos.y * xypos.y);
    	answer.angle = atan2(xypos.y, xypos.x);
    	return answer;
    }
    
    void show_polar(polar dapos) {
    	using namespace std;
    	const double Rad_to_deg = 57.29577951;
    
    	cout << "distance = " << dapos.distance;
    	cout << ", angle = " << dapos.angle * Rad_to_deg;
    	cout << " degrees\n";
    }
    ```

  * ```c++
    Enter the x and y values: 120 80
    distance = 144.222, angle = 33.6901 degrees
    Next two numbers <q to quit>: 120 50
    distance = 130, angle = 22.6199 degrees
    Next two numbers <q to quit>: q
    Bye!
    ```



### 9.2 储存持续性、作用域和连接性

* 1、C++使用四种不同的方案来储存数据，它们的区别在于数据保留在内存中的时间：
  * 自动存储持续性：在函数定义中声明的变量(包括函数参数)的存储持续性为自动的。它们在序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放C++有两种存储持续性为自动的变量。
  * 静态存储持续性：在函数定义外定义的变量和使用关键字 static 定义的变量的存储持续性都为静态。它们在程序整个运行过程中都存在。C++有3种存储持续性为静态的变量。
  * 线程存储持续性：当前，多核处理器很常见，这些 CPU 可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字 thread local 声明的，则其生命周期与所属的线程一样长。本书不探讨并行编程。
  * 动态存储持续性：用new运算符分配的内存将一直存在，直到使用 delete 运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自由存储 (free store)或堆 (heap)。



#### 9.2.1 作用域和链接

* 1、作用域（scope）描述了名称在文件（翻译单元）的多大范围内可见，例如：
  * 函数中定义的变量可在该函数中使用，但不能在其他函数中使用；
  * 而在文件中的函数定义之前定义的变量则可在所有函数中使用。
* 2、连接性（linkage）描述了名称如何在不同单元间共享。
  * 连接性为外部的名称可在文件间共享；
  * 连接性为内部的名称只能由一个文件中的函数共享。
  * 自动变量的名称没有连接性，因为它们不能共享。
* 3、变量的作用域种类：
  * 作用域为局部的变量只在定义它的代买块（由花括号括起一系列语句）中可用；
  * 作用域为全局的变量在定义位置到文件结尾之间都可用。
    * 在函数原型作用域中使用的名称、在类中声明的成员作用域、在名称空间中声明的变量的作用域......P305;
* 4、C++函数的作用域可以是整个类或整个名称空间，但不能是局部的。

#### 9.2.2 自动存储持续性

* 1、在默认情况下，函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。

  * 当程序开始执行这些变量所属的代码块时，将为其分配内存；当函数结束时，这些变量都将消失。

* 2、如果在代码块中定义了变量，则该变量的存在时间和作用域将被限制在该代码块内。

  * ```c++
    int main()
    {
        int teledeli = 5;
        {	//websight allocated
            cout << "Hello\n";
            int websight = -2;	//websight scope begins
            cout << teledeli << ' ' << teledeli << endl;
        }	//websight expires
        cout << teledeli << endl;
        ...
    }	//teledeli expires
    ```

  * 此时teledeli在内部代码块和外部代码块都可见，而websight只在内部代码块中可见。

  * 如果内部代码块中的websight改成teledeli，使得由两个同名的变量：

    * 程序执行内部代码块中的语句时，将teledeli解释为局部代码块变量。（新的定义隐藏了以前的定义，新定义可见，旧定义暂时不可见。在程序离开该代码块时，原来的定义又重新可见）
    * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/46db525a-d640-45dc-b077-b89a02fd1fa1)



  * 示例：

    * ```c++
      // ch09_04_auto.cpp -- illustrating scope of automatic variables
      #include<iostream>
      
      void oil(int x);
      int main() {
      	using namespace std;
      
      	int texas = 31;
      	int year = 2011;
      	cout << "In main(), texas = " << texas << ", &texas = ";
      	cout << &texas << endl;
      
      	cout << "In main(), year = " << year << ", &year =";
      	cout << &year << endl;
      
      	oil(texas);
      	cout << "In main(), texas = " << texas << ", &texas = ";
      	cout << &texas << endl;
      
      	cout << "In main(), year = " << year << ", &year =";
      	cout << &year << endl;
      
      	return 0;
      }
      
      void oil(int x) {
      	using namespace std;
      	int texas = 5;
      
      	cout << "In oil(), texas = " << texas << ", &texas = ";
      	cout << &texas << endl;
      
      	cout << "In oil(), x = " << x << ", &x = ";
      	cout << &x << endl;
      	{
      		int texas = 113;
      		cout << "In block, texas = " << texas;
      		cout << ", &texas = " << &texas << endl;
      		cout << "In block, x = " << x << ", &x = ";
      		cout << &x << endl;
      	}
      	cout << "Post-block texas = " << texas;
      	cout << ", &texas = " << &texas << endl;
      }
      ```

  * 结果：

    * ```c++
      In main(), texas = 31, &texas = 0136FD18
      In main(), year = 2011, &year =0136FD0C
      In oil(), texas = 5, &texas = 0136FC24
      In oil(), x = 31, &x = 0136FC38
      In block, texas = 113, &texas = 0136FC18
      In block, x = 31, &x = 0136FC38
      Post-block texas = 5, &texas = 0136FC24
      In main(), texas = 31, &texas = 0136FD18
      In main(), year = 2011, &year =0136FD0C
      ```

* 3、使用C++11中的auto

  * 关键字auto用于自动类型判断：P307

* 4、自动变量的初始化

  * 可以使用任何在声明时其值为已知的表达式来初始化自动变量：

    * ```c++
      int w;					//value of w is indeterminate(不确定)
      int x = 5;				//initialized with a numeric literal
      int big = INT_MAX - 1;	 //initialized with a constant expression
      int y = 2 * x;			//use previously determined value of x
      cin >> x;
      int z = 3 * w;			//use new value of w
      ```

* 5、自动变量和栈

  * 由于自动变量的数目随函数的开始和结束而增减，因此程序必须在运行时对自动变量进行管理。
  * 常用的方法时留出一段内存，并将其视为栈，以管理变量的增减。
  * 之所以被称为栈：是因为新数据被象征性的放在原有数据的上面，当程序使用完后，将其从栈中删除。
  * 栈时LIFO（后进先出），集最后加入到栈中的变量首先被弹出。（栈是弹夹结构）
    * 这种设计简化了参数传递。函数调用将其参数的值放在栈顶，然后重新设置栈顶指针。被调用的函数根据其形参描述来确定每个参数的地址。
    * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/50a850b2-ca8f-4e1e-887e-b5fd9a2f829b)


* 6、寄存器变量

  * 关键字register在C++中只是显式地指出变量是是自动的。
  * 鉴于关键字register只能用于原本就是自动地变量，使用它的卫衣原因是，指出程序员想使用一个自动变量，这个变量的名称可能与外部变量相同。
  * 这与auto以前的用途完全相同，然而保留关键字register的重要原因是：
    * 避免使用了该关键字的现有代码非法。

#### 9.2.3 静态持续变量

* C++为静态存储持续性变量提供了3种连接性：

  * 外部链接性（可在其他文件中访问）
  * 内部链接性（只能在当前文件中访问）
  * 无链接性（只能在当前函数或代码块中访问）
  * 这3种链接性都在整个程序执行期间存在，与自动变量相比，它们的寿命更长。

* 静态变量的数目在程序运行期间是不变的，因此程序不需要使用特殊的装置（如栈）来管理它们。编译器将分配固定的内存块来储存所有的静态变量，这些变量在整个程序执行期间一直存在。

  * 创建链接性为外部的静态持续变量，必须在代码块的外面声明它；

  * 创建链接性为内部的静态持续变量，必须在代码块的外面声明它，并使用static限定符；

  * 创建没有链接性的静态持续变量，必须在代码块内声明它，并使用static限定符。

    * ```c++
      ...
      int global = 1000;
      static int one_file = 50;
      int main(){
      ...
      }
      void funct1(int n){
          static int count = 0;
          int llama;
      ...
      }
      void funct2(int q){
      ...
      }
      ```

    * 所有静态持续变量（global、one_file和count）在整个程序执行期间都存在。

    * 在funct1( )中声明的变量count的作用域为局本，没有链接性：

      * 即只能在funct1( )函数中使用它，就像自动变量llama一样。
      * 然而与llama不同的是：
        * 及时在funct1( )函数没有被执行时，count也留在内存中。

    * global 和 one_file 的作用域都为整个文件，即在从声明位置到文件结尾的范围内都可以被使用。

      * 由于 one_file 的链接性为内部，因此只能在包含上述代码文件中使用它；
      * 由于 global 的链接性为外部，因此可以在程序的其他文件中使用它。

    * 所有静态持续变量都有下述初始化特征：未被初始化的静态变量的所有位都被设置为0。

    * 表 9.1 指出了关键字 static 的两种用法，但含义有些不同:用于局部声明，以指出变量是无链接性的静态变量时，static 表示的是存储持续性：而用于代码块外的声明时，static 表示内部链接性，而变量已经是静态持续性了。有人称之为关键字重载，即关键字的含义取决于上下文。

      * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/318da534-a3af-4657-99eb-2477b7f7c533)


* 静态变量的初始化

  * 除默认的零初始化外，还可以对静态变量进行常量表达式初始化和动态初始化。

    * 零初始化和常量表达式初始化被统称为静态初始化，这意味着在编译器处理文件（翻译单元）时初媒化变量。动态初始化意味着变量将在编译后初始化。

    * 常量表达式并非只能使用字面常量的计算表达式，例如还可以使用sizeof运算符：

      * ```c++
        int enough = 2 + sizeof (long) + 1;
        ```



#### 9.2.4 静态持续性、外部链接性

* 链接性为外部的变量通常简称为外部变量，它们的存储持续性为静态，作用域为整个文件。（在main函数之前声明定义，并且不使用static等任何关键字。）

  * 因此外部变量也称为全局变量。

* 1、单定义规则

  * 一方面，在每个使用外部变量的文件中，都必须声明它；

  * 另一方面，C++有“单定义规则”：

    * 变量只能有一次定义。

  * 为了解决这两个需求，C++提供了两种变量声明：

    * 1 定义声明（定义），它给变量分配存储空间；

    * 2 引用声明（声明），它不给变量分配存储空间，因为它引用已有的变量。

      * 引用声明使用关键字 extern ，且不进行初始化；否则声明为定义，导致分配存储空间：

        * ```c++
          double up;
          extern int blem;	//blem defined elsewhere
          extern char gr = 'z';//definition because initialized
          ```

      * 如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义（单定义规则），但在使用该变量的其他所有文件中，都必须使用关键字 extern 声明它。

        * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/79348bd3-b284-4fd4-b4fd-20d2ecbe8af9)


* 2、如果在函数中声明了一个与外部变量同名的变量，结果将如何呢？

  * 示例：

    * ```c++
      // ch09_05_external.cpp -- external variables
      // compile with support.cpp
      #include <iostream>
      using namespace std;
      
      //external variable
      double warming = 0.3;
      
      void update(double dt);
      void local();
      
      int main() {
      	cout << "Global warming is " << warming << " degrees.\n";
      	update(0.1);
      	cout << "Global warming is " << warming << " degrees.\n";
      	local();
      	cout << "Global warming is " << warming << " degrees.\n";
      	return 0;
      }
      ```

  * 示例：

    * ```c++
      // ch09_06_support.cpp -- use external variable
      // compile with external.cpp
      #include <iostream>
      extern double warming;
      
      void update(double dt);
      void local();
      
      using std::cout;
      
      void update(double dt) {
      	extern double warming;
      	warming += dt;
      	cout << "Updating global warming to " << warming;
      	cout << " degrees.\n";
      }
      
      void local() {
      	double warming = 0.8;
      
      	cout << "Local warming = " << warming << " degrees.\n";
      	cout << "But global warming = " << ::warming;//作用域解析运算符(::)。放在变量名前面时，该运算符表示使用变量的全局版本。
      	cout << " degrees.\n";
      }
      ```

  * 结果：

    * ```c++
      Global warming is 0.3 degrees.
      Updating global warming to 0.4 degrees.
      Global warming is 0.4 degrees.
      Local warming = 0.8 degrees.
      But global warming = 0.4 degrees.
      Global warming is 0.4 degrees.
      ```

      * local( )函数表明，定义与全局变量同名的局部变量后，局部变量将隐藏全局变量。
      * 作用域解析运算符(::)。放在变量名前面时，该运算符表示使用变量的* * * * 全局版本。

* 全局变量和局部变量的选取
  * 全局变量：所有的函数都能访问全局变量，因此不用传递参数。但易于访问的代价很大——程序不可靠。
  * 通常情况下，应使用局部变量，应在知晓时才传递数据，而不应不加区分地使用全局变量来时数据可靠。

#### 9.2.5 静态持续性、内部链接性

* 将 static 限定符用于作用域为整个文件的变量时，该变量的链接性将为内部的。

* 如果要在其他文件中使用相同的名称来表示其他变量：

  * ```c++
    //file1
    int errors = 20；
    ...
    --------------------------------------------------
    //file2
    static int errors = 5;
    void froobish(){
        cout << errors;
        ...
    }
    ```

  * 需要在其他文件中对相同名称使用 static 指出标识符 errors 的链接性为内部，因此并非要提供外部定义。

    * 这样可以在链接性为内部的静态变量在同一个文件中的读个函数之间共享数据。

  * 如果要在多个文件程序中使用一个外部变量，只能在一个文件中定义一个外部变量。使用该变量的其他文件必须使用关键字 extern 声明它。

    * 这样可以使用外部变量在多文件程序的不同部分之间共享数据。

* 示例：

  * ```c++
    // ch09_07_twofile1.cpp -- variables with external and internal linkage
    #include <iostream>
    int tom = 3;			//external variable definition
    int dick = 30;			//external variable definition
    static int harry = 300;	//static, internal linkage
    
    void remote_access();
    
    int main() {
    	using namespace std;
    	cout << "main() repotys the following addresses:\n";
    	cout << &tom << " = &tom, " << &dick << " = &dick, ";
    	cout << &harry << " = &harry\n";
    	remote_access();
    
    	return 0;
    }
    ```

* 示例：

  * ```c++
    // ch09_08_twofile2.cpp -- variables with internal and external linkage
    #include <iostream>
    extern int tom;			//tom difined elsewhere
    static int dick = 10;	//overrides external dick;
    int harry = 200;		//external variable definition
    						//no conflict with twofile1 harry
    
    void remote_access() {
    	using namespace std;
    	cout << "remote_access() reports the following addresses:\n";
    	cout << &tom << " = &tom, " << &dick << " = dick, ";
    	cout << &harry << " = &harry\n";
    }
    ```

* 结果：

  * ```c++
    main() repotys the following addresses:
    00A5C000 = &tom, 00A5C004 = &dick, 00A5C008 = &harry
    remote_access() reports the following addresses:
    00A5C000 = &tom, 00A5C014 = dick, 00A5C010 = &harry
    ```



#### 9.2.6 静态存储持续性、无链接性

* 创建方法：

  * 将 static 限定符用于在代码块中定义的变量。即该变量只在该代码块中可用，但它在该代码块不处于活动状态时仍然存在。

* 示例：

  * ```c++
    // ch09_09_static.cpp -- using a static local variable
    #include <iostream>
    const int ArSize = 10;
    
    void strcount(const char* str);
    
    int main()
    {
    	using namespace std;
    	char input[ArSize];
    	char next;
    
    	cout << "Enter a line:\n";
    	cin.get(input, ArSize);
    	while (cin)
    	{
    		cin.get(next);
    		while (next != '\n')
    			cin.get(next);
    		strcount(input);
    		cout << "Enter next line (empty line to quit):\n";
    		cin.get(input, ArSize);
    	}
    	cout << "Bye.\n";
    	return 0;
    }
    
    void strcount(const char * str)
    {
    	using namespace std;
    	static int total = 0;
    	int count = 0;
    
    	cout << "\"" << str << "\" contains ";
    	while (*str++)
    		count++;
    	total += count;
    	cout << count << " characters\n";
    	cout << total << " characters total\n";
    }
    ```

  * 结果：

    * ```c++
      Enter a line:
      nice pants
      "nice pant" contains 9 characters
      9 characters total
      Enter next line (empty line to quit):
      thanks
      "thanks" contains 6 characters
      15 characters total
      Enter next line (empty line to quit):
      parting is such sweet sorrow
      "parting i" contains 9 characters
      24 characters total
      Enter next line (empty line to quit):
      ok
      "ok" contains 2 characters
      26 characters total
      Enter next line (empty line to quit):
      
      Bye.
      ```

      * 每次函数被调用时候，自动变量 count 都会被重置为0，然而静态变量 total 只在程序运行时被这是为0，以后在两次函数调用之间，其值将保持不变，因此能够记录读取的字符总数。



#### 9.2.7 说明符和限定符
