## 第九章 内存模型和名称空间

### 9.1 单独编译

* 1、C++允许将组件函数放在独立的文件中。

* 2、原来在一个文件内编写程序时，将支持函数放在main()函数之后。如果将原来文件分为两个，但是main()函数和支持函数使用了同一个数据结构声明。因此将一个程序放在多个文件中将引出新的问题：

  * 解决办法：使用“#include”来处理这种情况，将结构声明放在头文件中，然后在每个源代码文件中都包含该头文件。
  * 这样要修改结构声明时，只需在头文件中做一次改动即可。
  * 另外，也可以将函数原型放在头文件中。
  * 因此，可将原来的程序分为三部分：
    * 头文件：包含结构声明和使用这些结构的函数的原型；
    * 源代码文件：包含与结构有关的函数的代码；
    * 源代码文件：包含调用与结构相关的函数的代码。

* 3、📌不要将**函数定义**或**变量声明**放到头文件中。头文件中常包含的内容：

  * 函数原型。
  * 使用#define或const定义的符号常量。
  * 结构声明。
  * 类声明。
  * 模板声明。
  * 内联函数。

* 4、示例：

  * 程序清单09_01，程序清单09_02，程序清单09_03是将清单07_12分成个独部后得到的结果。

  * 在包含头文件时，使用“coordin.h”而不是<coordin.h>。

    * 如果文件名包含在尖括号中，则C++编译器将在储存标准头文件的主机系统的文件系统中查找；
    * 但如果文件名包含在双引号中，则C++编译器将首先查找当前的工作目录或源代码目录。如果没有找到，则将在标准的位置查找。
    * 因此在包含**自己**的头文件时，使用双引号。

  * 图9.1简要地说明了在UNIX 系统中将该程序组合起来的步骤：

    * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/6e114ad2-e50d-40ff-8eda-a6122e3d6ef6)


  * 警告：在IDE中，不要将头文件加入到项目列表中，也不要在源代码文件中使用#imclude 来包含其他源代码文件。

  * ```c++
    // ch09_01_coordin.h -- structyre templates and function prototypes
    // structure templates
    
    #ifndef COORDIN_H_
    #define COORDIN_H_
    
    struct polar {
    	double distance;
    	double angle;
    };
    
    struct rect {
    	double x;
    	double y;
    };
    
    // prototypes
    polar rect_to_polar(rect xypos);
    void show_polar(polar dapos);
    
    #endif
    ```

    * 仅当以前没有使用预处理编译指令#define定义名称COORDIN_H_时，才处理 #ifndef 和 #endif 之间的语句：

      * ```c++
        #ifndef COORDIN_H_
        ...
        #endif
        ```

    * 通常，使用 #define 语句来创建符号常量，如下所示：

      * ```c++
        #define MAXIMUM 4096
        ```

    * 但只要将 #define 用于名称，就足以完成该名称的定义：

      * ```c++
        #define COORDIN_H_
        ```

    * 程序清单09_01使用这种技术是为了将头文件内容包含在 #ifndef中：

      * ```c++
        #ifndef COORDIN_H_
        #define COORDIN_H_
        // place include file contents here
        #endif
        ```

  * ```c++
    // ch09_02_file1.cpp -- example of a three-file program
    #include<iostream>
    #include"coordin.h"
    using namespace std;
    int main() {
    	rect rplace;
    	polar pplace;
    
    	cout << "Enter the x and y values: ";
    	while (cin >> rplace.x >> rplace.y) {
    		pplace = rect_to_polar(rplace);
    		show_polar(pplace);
    		cout << "Next two numbers <q to quit>: ";
    	}
    	cout << "Bye!\n";
    	return 0;
    }
    ```

  * ```c++
    // ch09_03_file2.cpp -- contains functions called in file1.cpp
    #include<iostream>
    #include<cmath>
    #include"coordin.h"
    
    polar rect_to_polar(rect xypos) {
    	using namespace std;
    	polar answer;
    
    	answer.distance =
    		sqrt(xypos.x * xypos.x + xypos.y * xypos.y);
    	answer.angle = atan2(xypos.y, xypos.x);
    	return answer;
    }
    
    void show_polar(polar dapos) {
    	using namespace std;
    	const double Rad_to_deg = 57.29577951;
    
    	cout << "distance = " << dapos.distance;
    	cout << ", angle = " << dapos.angle * Rad_to_deg;
    	cout << " degrees\n";
    }
    ```

  * ```c++
    Enter the x and y values: 120 80
    distance = 144.222, angle = 33.6901 degrees
    Next two numbers <q to quit>: 120 50
    distance = 130, angle = 22.6199 degrees
    Next two numbers <q to quit>: q
    Bye!
    ```



### 9.2 储存持续性、作用域和连接性

* 1、C++使用四种不同的方案来储存数据，它们的区别在于数据保留在内存中的时间：
  * 自动存储持续性：在函数定义中声明的变量(包括函数参数)的存储持续性为自动的。它们在序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放C++有两种存储持续性为自动的变量。
  * 静态存储持续性：在函数定义外定义的变量和使用关键字 static 定义的变量的存储持续性都为静态。它们在程序整个运行过程中都存在。C++有3种存储持续性为静态的变量。
  * 线程存储持续性：当前，多核处理器很常见，这些 CPU 可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字 thread local 声明的，则其生命周期与所属的线程一样长。本书不探讨并行编程。
  * 动态存储持续性：用new运算符分配的内存将一直存在，直到使用 delete 运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自由存储 (free store)或堆 (heap)。



#### 9.2.1 作用域和链接

* 1、作用域（scope）描述了名称在文件（翻译单元）的多大范围内可见，例如：
  * 函数中定义的变量可在该函数中使用，但不能在其他函数中使用；
  * 而在文件中的函数定义之前定义的变量则可在所有函数中使用。
* 2、连接性（linkage）描述了名称如何在不同单元间共享。
  * 连接性为外部的名称可在文件间共享；
  * 连接性为内部的名称只能由一个文件中的函数共享。
  * 自动变量的名称没有连接性，因为它们不能共享。
* 3、变量的作用域种类：
  * 作用域为局部的变量只在定义它的代买块（由花括号括起一系列语句）中可用；
  * 作用域为全局的变量在定义位置到文件结尾之间都可用。
    * 在函数原型作用域中使用的名称、在类中声明的成员作用域、在名称空间中声明的变量的作用域......P305;
* 4、C++函数的作用域可以是整个类或整个名称空间，但不能是局部的。

#### 9.2.2 自动存储持续性

* 1、在默认情况下，函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。

  * 当程序开始执行这些变量所属的代码块时，将为其分配内存；当函数结束时，这些变量都将消失。

* 2、如果在代码块中定义了变量，则该变量的存在时间和作用域将被限制在该代码块内。

  * ```c++
    int main()
    {
        int teledeli = 5;
        {	//websight allocated
            cout << "Hello\n";
            int websight = -2;	//websight scope begins
            cout << teledeli << ' ' << teledeli << endl;
        }	//websight expires
        cout << teledeli << endl;
        ...
    }	//teledeli expires
    ```

  * 此时teledeli在内部代码块和外部代码块都可见，而websight只在内部代码块中可见。

  * 如果内部代码块中的websight改成teledeli，使得由两个同名的变量：

    * 程序执行内部代码块中的语句时，将teledeli解释为局部代码块变量。（新的定义隐藏了以前的定义，新定义可见，旧定义暂时不可见。在程序离开该代码块时，原来的定义又重新可见）
    * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/46db525a-d640-45dc-b077-b89a02fd1fa1)



  * 示例：

    * ```c++
      // ch09_04_auto.cpp -- illustrating scope of automatic variables
      #include<iostream>
      
      void oil(int x);
      int main() {
      	using namespace std;
      
      	int texas = 31;
      	int year = 2011;
      	cout << "In main(), texas = " << texas << ", &texas = ";
      	cout << &texas << endl;
      
      	cout << "In main(), year = " << year << ", &year =";
      	cout << &year << endl;
      
      	oil(texas);
      	cout << "In main(), texas = " << texas << ", &texas = ";
      	cout << &texas << endl;
      
      	cout << "In main(), year = " << year << ", &year =";
      	cout << &year << endl;
      
      	return 0;
      }
      
      void oil(int x) {
      	using namespace std;
      	int texas = 5;
      
      	cout << "In oil(), texas = " << texas << ", &texas = ";
      	cout << &texas << endl;
      
      	cout << "In oil(), x = " << x << ", &x = ";
      	cout << &x << endl;
      	{
      		int texas = 113;
      		cout << "In block, texas = " << texas;
      		cout << ", &texas = " << &texas << endl;
      		cout << "In block, x = " << x << ", &x = ";
      		cout << &x << endl;
      	}
      	cout << "Post-block texas = " << texas;
      	cout << ", &texas = " << &texas << endl;
      }
      ```

  * 结果：

    * ```c++
      In main(), texas = 31, &texas = 0136FD18
      In main(), year = 2011, &year =0136FD0C
      In oil(), texas = 5, &texas = 0136FC24
      In oil(), x = 31, &x = 0136FC38
      In block, texas = 113, &texas = 0136FC18
      In block, x = 31, &x = 0136FC38
      Post-block texas = 5, &texas = 0136FC24
      In main(), texas = 31, &texas = 0136FD18
      In main(), year = 2011, &year =0136FD0C
      ```

* 3、使用C++11中的auto

  * 关键字auto用于自动类型判断：P307

* 4、自动变量的初始化

  * 可以使用任何在声明时其值为已知的表达式来初始化自动变量：

    * ```c++
      int w;					//value of w is indeterminate(不确定)
      int x = 5;				//initialized with a numeric literal
      int big = INT_MAX - 1;	 //initialized with a constant expression
      int y = 2 * x;			//use previously determined value of x
      cin >> x;
      int z = 3 * w;			//use new value of w
      ```

* 5、自动变量和栈

  * 由于自动变量的数目随函数的开始和结束而增减，因此程序必须在运行时对自动变量进行管理。
  * 常用的方法时留出一段内存，并将其视为栈，以管理变量的增减。
  * 之所以被称为栈：是因为新数据被象征性的放在原有数据的上面，当程序使用完后，将其从栈中删除。
  * 栈时LIFO（后进先出），集最后加入到栈中的变量首先被弹出。（栈是弹夹结构）
    * 这种设计简化了参数传递。函数调用将其参数的值放在栈顶，然后重新设置栈顶指针。被调用的函数根据其形参描述来确定每个参数的地址。
    * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/50a850b2-ca8f-4e1e-887e-b5fd9a2f829b)


* 6、寄存器变量

  * 关键字register在C++中只是显式地指出变量是是自动的。
  * 鉴于关键字register只能用于原本就是自动地变量，使用它的卫衣原因是，指出程序员想使用一个自动变量，这个变量的名称可能与外部变量相同。
  * 这与auto以前的用途完全相同，然而保留关键字register的重要原因是：
    * 避免使用了该关键字的现有代码非法。

#### 9.2.3 静态持续变量
