## 第十三章 类继承

面向对象编程的主要目的之一是提供可重用的代码。开发新项目，尤其是当项目十分庞大时，重用经过测试的代码比重新编写代码要好得多。使用已有的代码可以节省时间，由于已有的代码已被使用和测试过，因此有助于避免在程序中引入错误。另外，必须考虑的细节越少，便越能专注于程序的整体策略。

C++提供了比修改代码更好的方法来扩展和修改类。这种方法叫作类继承，它能够从已有的类派生出新的类，而派生类继承了原有类（称为基类）的特征，包括方法。

* 可以在已有类的基础上添加功能。例如，对于数组类，可以添加数学运算。
* 可以给类添加数据。例如，对于字符串类，可以派生出一个类，并添加指定字符串显示颜色的数据成员。
* 可以修改类方法的行为。例如，对于代表提供给飞机乘客的服务的 Passenger 类可以派生出提供更高级别服务的FirstClassPassenger 类。

当然，可以通过复制原始类代码，并对其进行修改来完成上述工作，但继承机制只需提供新特性，甚至不需要访问源代码就可以派生出类。

### 13.1 一个简单的基类

从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。

* 1、基类：

  * 以Webtown俱乐部决定跟踪乒乓球会会员为例，设计一个简单的 TableTennisPlayer 类。

  * TableTennisPlayer 类只是记录会员的姓名以及是否有球桌。

    * ```c++
      #pragma once
      // ch13_01_tabtenn0.h -- a table-tennis base class
      #ifndef CH13_01_TABTENN0_H_
      #define CH13_01_TABTENN0_H_
      #include <string>
      
      using std::string;
      // simple base class
      class TableTennisPlayer
      {
      private:
      	string firstname;
      	string lastname;
      	bool hasTable;
      public:
      	TableTennisPlayer(const string& fn = "none", const string& ln = "none", bool ht = false);
      	void Name() const;
      	bool HasTable() const { return hasTable; };
      	void ResetTable(bool v) { hasTable = v; };
      };
      #endif
      ```

    * ```c++
      // ch13_02_tabtenn0.cpp -- simple base-class method
      #include "ch13_01_tabtenn0.h"
      #include <iostream>
      
      TableTennisPlayer::TableTennisPlayer(const string & fn, 
      	const string & ln, bool ht) : firstname(fn), 
      	lastname(ln), hasTable(ht) {}
      
      void TableTennisPlayer::Name() const
      {
      	std::cout << lastname << ", " << firstname;
      }
      ```

      * 其中ch13_02_tabtenn0.cpp使用了第12章介绍的成员初始化列表语法，等价于下面内容：

        * ```c++
          TableTennisPlayer::TableTennisPlayer(const string & fn, 
          	const string & ln, bool ht)
          {
          	firstname = fn; 
          	lastname = ln;
              hasTable = ht;
          }
          ```

        * 详细步骤是：

          * 这将首先为 firstname 调用 string 的默认构造函数，再调用 string 的赋值运算符将 firstname 设置为 fn，
          * 但初始化列表语法可减少一个步骤，它直接使用 string 的复制构造函数将 firstname 初始化为 fn

    * ```c++
      // ch13_03_usett0.cpp -- using a base class
      #include <iostream>
      #include "ch13_01_tabtenn0.h"
      
      int main(void)
      {
      	using std::cout;
      	TableTennisPlayer player1("Chuck", "Blizzard", true);
      	TableTennisPlayer player2("Tara", "Boomdea", false);
      
      	player1.Name();
      	if (player1.HasTable())
      		cout << ": has a table.\n";
      	else
      		cout << ": hasn't a table.\n";
      
      	player2.Name();
      	if (player2.HasTable())
      		cout << ": has a table.\n";
      	else
      		cout << ": hasn't a table.\n";
      
      	return 0;
      }
      ```

  * 结果：

    * ```c++
      Blizzard, Chuck: has a table.
      Boomdea, Tara: hasn't a table.
      ```

    * 注意到该程序实例化对象时将 C-风格字符串作为参数：

      * ```c++
        TableTennisPlayer player1("Chuck", "Blizzard", true);
        TableTennisPlayer player2("Tara", "Boomdea", false);
        ```

      * 但构造函数的形参类型被声明为 const string &。这导致类型不匹配，但与第12章创建的 String 类一样，string 类有一个将 const char * 作为参数的构造函数，使用C-风格字符串初始化 string 对象时，将自动调用这个构造函数。

      * 总之，**可将 string 对象或C-风格字符串作为构造函数 TableTennisPlayer 的参数**：

        * 将前者作为参数时，将调用接受 const string & 作为参数的 string 构造函数；
        * 而将后者作为参数时，将调用接受 const char* 作为参数的 string 构造函数。

#### 13.1.1 派生一个类

Webtown 俱乐部的一些成员**曾经**参加过当地的乒乓球锦标赛：需要这样一个类，它能包括成员在比赛中的比分。

* 与其从零开始，不如从 TableTennisClass 类派生出一个类。首先将 RatedPlayer 类声明为从 TableTennisClass 类派生而来：

  * ```c++
    // RatedPlayer derives from the TableTennisPlayer base class
    class RatedPlayer : public TableTennisPlayer
    {
    ...
    };
    ```

  * 冒号指出 RatedPlayer 类的基类是 public TableTennisPlayer 类。

  * “class RatedPlayer : public TableTennisPlayer”特殊的声明头表明 TableTennisPlayer 是一个公有基类，这被称为公有派生。

    * 派生类对象包含基类对象；
    * 使用公有派生：
      * 基类的公有成员将成为派生类的共有成员；
      * 基类的私有部分称为派生类的一部分，但只能通过基类的公有和保护方法访问。

  * RatedPlayer 对象将具有以下特征：

    * 派生类对象储存了基类的数据成员（派生类继承了基类的实现）；
    * 派生类对象可以使用基类的方法（派生类继承了基类的接口）。
    * 因此，RatedPlayer 对象可以储存运动员的姓名及其是否有球桌，另外还可以使用 T 类的Name()、hasTable()、ResetTable()方法：
      * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/3dc3f49a-a1a3-490d-9ed5-5ecbb3b498fe)

  * 需要再继承特性中添加什么呢：

    * 派生类需要自己的构造函数。

    * 派生类可以根据需要添加额外的数据成员和成员函数。

    * 在这个例子中，派生类需要另一个数据成员来存储比分，还应包含检索比分的方法和重置比分的方法。因此，类声明与下面类似：

      * ```c++
        // simple detived class
        class RatedPlayer : public TableTennisPlayer
        {
        private:
            unsigned int rating;	// add a data member
        public:
            RatedPlayer (unsigned int r = 0, const string & fn = "none", const string& ln = "none", bool ht = false);
            RatedPlayer (unsigned int r, const TableTennisPlayer & tp);
            unsigned int Rating () const { return rating; }		// add a method
            void ResetRating (unsigned int r) { rating = r; }	// add a method
        };
        ```

#### 13.1.2 构造函数：访问权限的考虑

📌派生类不能直接访问基类的私有成员，而必须通过基类方进行访问。具体地说，派生类构造函数必须使用基类构造函数。

创建派生对象时，程序首先创建基类对象：

* ```c++
  RatedPlayer::RatedPlayer(unsigned int r, const string & fn,
                          const string & ln, bool ht) : TableTennisPlayer(fn, 
                          ln, ht)
  {
      rating = r;
  }
  ```

* 其中：**TableTennisPlayer (fn, ln, ht) 是成员初始化列表**。它是可执行的代码，调用TableTennisPlayer构造函数：

  * ```C++
    RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
    ```

    * RatedPlayer构造函数将把实参（"Mallory", "Duck", true）赋给形参（fn, ln, ht）
    * 然后将这些参数作为实参传递给TableTennisPlayer构造函数，该函数将创建一个嵌套TableTennisPlayer对象，并将数据（"Mallory", "Duck", true）存储在该对象中。
    * 最后，程序进入RatedPlayer构造函数构造函数体，完成RealPlayer对象的创建，并将参数的 r 值（1140）赋给rating成员：
      * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/24b7d846-aaf7-447f-b044-20ad6e2dc6c2)


  * 如果省略成员初始化列表，程序会使用默认的基类构造函数进行创建基类对象，见P485

* 如果愿意，也可以对派生类成员使用成员初始化列表语法。在这种情况下，应在列表中使用**成员名**，而不是类名。所以，第二个构造函数可以按照下述方式编写：

  * ```c++
    // alternative version
    RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer & tp)
        : TableTennisPlayer(tp), rating(r)
        {
        }
    ```

* 有关派生类构造函数的要点如下：

  * 首先创建基类对象；
  * 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；
  * 派生类构造函数应初始化派生类新增的数据成员。

* 创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数：

  * 基类构造函数负责初始化继承的数据成员；
  * 派生类构造函数主要用于初始化新增的数据成员。
    * 派生类的构造函数总是调用一个基类构造函数。可以使用初始化器列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。
    * 派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。

📌成员初始化列表：

* 派生类构造函数可以使用初始化器列表机制将值传递给基类构造函数：

  * ```c++
    derived::derived(type1 x, type2 y) : base(x, y)
    {
        ...
    }
    ```

  * 其中 derived 是派生类，base 是基类，x和y是基类构造函数使用的变量。

  * 如果没有在成员初始化列表中提供基类构造函数，程序将使用默认的基类构造函数。成员初始化列表只能用于构造函数。



#### 13.1.3 使用派生类

要使用派生类，程序必须要**能够访问基类声明**。程序清单 13.4 将这**两种类**的**声明**置于**同一个头文件**中。也可以将每个类放在独立的头文件中，但由于这两个类是相关的，所以把其类声明放在一起更合适。

* 示例：

  * ```c++
    #pragma once
    // ch13_04_tabtenn1.h -- a table-tennis base class
    #ifndef CH13_04_TABTENN1_H_
    #define CH13_04_TABTENN1_H_
    #include<string>
    using std::string;
    // simple base class
    class TableTennisPlayer
    {
    private:
    	string firstname;
    	string lastname;
    	bool hasTable;
    public:
    	TableTennisPlayer(const string& fn = "none",
    					  const string& ln = "none", bool ht = false);
    	void Name() const;
    	bool HasTable() const { return hasTable; };
    	void ResetTable(bool v) { hasTable = v; };
    };
    
    // simple derived class
    class RatedPlayer : public TableTennisPlayer
    {
    private:
    	unsigned int rating;
    public:
    	RatedPlayer(unsigned int r = 0, const string& fn = "none",
    				const string& ln = "none", bool ht = false);
    	RatedPlayer(unsigned int r, const TableTennisPlayer& tp);
    	unsigned int Rating() const { return rating; }
    	void ResetRating(unsigned int r) { rating = r; }
    };
    #endif
    ```

  * ```c++
    // ch13_05_tabtenn1.cpp -- simple base-class methods
    #include "ch13_04_tabtenn1.h"
    #include <iostream>
    
    TableTennisPlayer::TableTennisPlayer (const string & fn,
    	const string & ln, bool ht) : firstname(fn),
    	lastname(ln), hasTable(ht) {}
    
    void TableTennisPlayer::Name() const
    {
    	std::cout << lastname << ", " << firstname;
    }
    
    // RatedPlayer methods
    RatedPlayer::RatedPlayer (unsigned int r, const string& fn,
    	const string& ln, bool ht) : TableTennisPlayer(fn, ln, ht)
    {
    	rating = r;
    }
    
    RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer& tp)
    	: TableTennisPlayer(tp), rating(r)
    {
    }
    ```

  * ```c++
    // ch13_06_usett1.cpp -- using base class and derived class
    #include <iostream>
    #include "ch13_04_tabtenn1.h"
    
    int main(void)
    {
    	using std::cout;
    	using std::endl;
    	TableTennisPlayer player1("Tara", "Boomdea", false);
    	RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
    	rplayer1.Name();
    	if (rplayer1.HasTable())
    		cout << ": has a table.\n";
    	else
    		cout << ": hasn't a table.\n";
    	player1.Name();
    	if (player1.HasTable())
    		cout << ": has a table\n";
    	else
    		cout << ": hasn't a table.\n";
    	cout << "Name: ";
    	rplayer1.Name();
    	cout << "; Rating: " << rplayer1.Rating() << endl;
    	RatedPlayer rplayer2(1212, player1);
    	cout << "Name: ";
    	rplayer2.Name();
    	cout << "; Rating: " << rplayer2.Rating() << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    Duck, Mallory: has a table.
    Boomdea, Tara: hasn't a table.
    Name: Duck, Mallory; Rating: 1140
    Name: Boomdea, Tara; Rating: 1212
    ```



#### 13.1.4 派生类和基类之间的特殊关系

（1）派生类对象可以使用基类的方法，条件是方法不是私有的；

* ```c++
  RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
  rplayer1.Name();
  ```

（2）基类指针可以在不进行显式类型转换的情况下指向派生类对象；

* ```c++
  RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
  TableTennisPlayer * pt = &rplayer;
  py->Name();
  ```

（3）基类应用可以在不进行显式类型转换的情况下引用派生类对象/

* ```c++
  RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
  TableTennisPlayer & rt = rplayer;
  rt.Name();
  ```

❗基类**指针**或**引用**只能调用基类方法，因此，不能使用rt或pt来调用派生类的ResetRanking方法。

❗可以将派生类对象和地址赋给基类应用和指针。（包含关系）

* 通常，C++要求引用和指针类型与赋给的类型匹配，但这一规则对**继承**来说是例外。然而，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针。
* 代码见P488，这一部分很深奥，在后续应用过程中可以反复翻阅查看



### 13.2 继承：is-a关系

派生类和基类之间的特殊关系是基于C++继承的底层模型。实际上C++有3种继承方式：（公有继承、保护继承、私有继承）

* 公有继承：
  * is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行。
    * 与该模型不符的例子：P490
      * has-a关系
      * is-like-a关系
      * is-implemented-as-a关系
      * use-a关系



### 13.3 多态公有继承

多态：具有多种形态的复杂行为，即方法的行为应取决于调用该方法的对象。

* 之前讲述的继承很简单，派生类对象使用基类的方法，而未做任何改变。然而，可能会遇到这样的情况，即希望同一个方法在派生类的和基类种的行为是不同的。

用于实现多态公有继承的两种重要机制：

* 在派生类种重新定义基类的方法；
* 使用虚方法。

示例：创建两个类

* 1、用于表示基本支票账户——Brass Account
* 2、调价了透支保护性的支票保护——Brass Plus

从Brass公有类派生出BrassPlus，并且BrassPlus类满足is-a条件（is-a关系通常不可逆：水果不是香蕉，同样，Brass对象不具备BrassPlus对象的所有功能。

#### 13.3.1 开发Brass类和BrassPlus类

见P491

* 示例：

  * ```c++
    //ch13_07_brass.h -- bank account classes
    #ifndef CH13_07_BRASS_H_
    #define CH13_07_BRASS_H_
    #include <iostream>
    // Brass Account Class
    class Brass
    {
    private:
    	std::string fullName;
    	long acctNum;
    	double balance;
    public:
    	Brass(const std::string& s = "Nullbody", long an = -1,
    		double bal = 0.0);
    	void Deposit(double amt);
    	virtual void Withdraw(double amt);
    	double Balance() const;
    	virtual void ViewAcct() const;
    	virtual ~Brass() {}
    };
    
    // Brass Plus Account Class
    class BrassPlus : public Brass
    {
    private:
    	double maxLoan;
    	double rate;
    	double owesBank;
    public:
    	BrassPlus(const std::string& s = "Nullbody", long an = -1,
    		double bal = 0.0, double ml = 500,
    		double r = 0.11125);
    	BrassPlus(const Brass & ba, double ml = 500,
    		double r = 0.11125);
    	virtual void ViewAcct() const;
    	virtual void Withdraw(double amt);
    	void ResetMax(double m) { maxLoan = m; }
    	void ResetRate(double r) { rate = r; }
    	void ResetOwes() { owesBank = 0; }
    };
    
    #endif
    ```

    * BrassPlus 类在 Brass 类的基础上添加了3个有数据成员和3公有成员函数；
    * Brass 类和 BrassPlus 类都声明了 ViewAcct() 和 Withdraw() 方法, BrassPlus 对象和 Brass 对象的这些方法的行为是不同的；
    * Brass 类在声明 ViewAcct() 和 Withdraw() 时使用了新关键字 **virtual**。这些方法被称为**虚方法(virtualmethod)**；见P493
      * 如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。
      * 如果没有使用关键字 virtual，程序将根据引用类型或指针类型选择方法；
      * 如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法。
      * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/6217972f-e18f-4795-a50f-e3817fc3859d)
    * Brass 类还声明了一个虚析构函数，虽然该析构函数不执行任何操作。
      * 基类声明了一个虚析构函数。这样做是为了确保释放派生对象时，按正确的顺序调用析构函数。

  * 📌如果要在**派生类**中重**新定义基类**的方法，通常应**将基类方法声明为虚的**。这样，程序将根据对象类型而不是引用或指针的类型来选择方法版本。为基类声明一个虚析构函数也是一种惯例。

**1、类实现**

* 示例：

  * ```c++
    // ch13_08_brass.cpp -- bank account class methods
    #include <iostream>
    #include "ch13_07_brass.h"
    using std::cout;
    using std::endl;
    using std::string;
    
    // formatting stuff
    typedef std::ios_base::fmtflags format;
    typedef std::streamsize precis;
    format setFormat();
    void restore(format f, precis p);
    
    // Brass methods
    
    Brass::Brass(const string& s, long an, double bal)
    {
    	fullName = s;
    	acctNum = an;
    	balance = bal;
    }
    
    void Brass::Deposit(double amt)
    {
    	if (amt < 0)
    		cout << "Negative deposit not allowed; "
    		<< "deposit is cancelled.\n";
    	else
    		balance += amt;
    }
    
    void Brass::Withdraw(double amt)
    {
    	// set up ###.## format
    	format initialState = setFormat();
    	precis prec = cout.precision(2);
    
    	if (amt < 0)
    		cout << "Withdrawal amount must be positive;"
    		<< "withdrawal canceled.\n";
    	else if (amt <= balance)
    		balance -= amt;
    	else
    		cout << "Withdrawal amount of $" << amt
    			 << " exceeds your balance.\n"
    			 << "Withdrawal canceled.\n";
    	restore(initialState, prec);
    }
    
    double Brass::Balance() const
    {
    	return balance;
    }
    
    void Brass::ViewAcct() const
    {
    	// set up ###.## format
    	format initialState = setFormat();
    	precis prec = cout.precision(2);
    	cout << "Client: " << fullName << endl;
    	cout << "Account Number: " << acctNum << endl;
    	cout << "Balance: $" << balance << endl;
    	restore(initialState, prec);
    }
    
    // BrassPlus Methods
    BrassPlus::BrassPlus(const string& s, long an, double bal,
    	double ml, double r) : Brass(s, an, bal)
    {
    	maxLoan = ml;
    	owesBank = 0.0;
    	rate = r;
    }
    
    BrassPlus::BrassPlus(const Brass& ba, double ml, double r)
    	: Brass(ba)	// use implicit copy constructor
    {
    	maxLoan = ml;
    	owesBank = 0.0;
    	rate = r;
    }
    
    // redefine how ViewAcct() works
    void BrassPlus::ViewAcct() const
    {
    	// set up ###.## format
    	format initialState = setFormat();
    	precis prec = cout.precision(2);
    
    	Brass::ViewAcct();
    	cout << "Maximum loan: $" << maxLoan << endl;
    	cout << "Owed to bank: $" << oweBank << endl;
    	cout.precision(3);
    	cout << "Loan Rate: " << 100 * rate << "&\n";
    	restore(initialState, prec);
    }
    
    // redefine how Withdraw() works
    void BrassPlus::Withdraw(double amt)
    {
    	// set up ###.## format
    	format initialState = setFormat();
    	precis prec = cout.precision(2);
    
    	double bal = Balance();
    	if (amt <= bal)
    		Brass::Withdraw(amt);
    	else if (amt <= bal + maxLoan - owesBank)
    	{
    		double advance = amt - bal;
    		owesBank += advance * (1.0 + rate);
    		cout << "Bank advance: $" << advance << endl;
    		cout << "Finance charge: $" << advance * rate << endl;
    		Deposit(advance);
    		Brass::Withdraw(amt);
    	}
    	else
    		cout << "Credit limit exceeded. Transaction cancelled.\n";
    	restore(initialState, prec);
    }
    
    format setFormat()
    {
    	// set up ###.## format
    	return cout.setf(std::ios_base::fixed,
    		std::ios_base::floatfield);
    }
    
    void restore(format f, precis p)
    {
    	cout.setf(f, std::ios_base::floatfield);
    	cout.precision(p);
    }
    ```

    * 派生类并不能直接访问基类的私有数据，而必须使用基类的公有方法才能访问这些数据。
      * 派生类构造函数在初始化基类私有数据时，采用的是**成员初始化列表**语法。RatedPlayer 类构造函数和BrassPlus构造函数都使用这种技术。P496
        * 将基类信息传递给基类构造函数，然后使用构造函数体初始化BrassPlus类新增的数据项。
      * 非构造函数不能使用成员初始化列表语法，但派生类方法可以调用公有的基类方法。P496
        * 在派生类方法中，标准技术是使用作用域解析运算符来调用基类方法。
        * 如果派生类没有重新定义该方法，代码不必对函数使用作用域解析运算符。
      * 方法 ViewAcct() 和 Withdraw() 使用格式化方法 setf() 和 precision() 将点值的输出模式设置为定点，即包含两位小数。设置模式后，输出的模式将保持不变，因此该方法将格式模式重置为调用前的状态。
      * 函数 setFormat() 设置定点表示法并返回以前的标记设置；
      * 而函数restore()重置格式和精度。

**2、使用 Brass 和 BrassPlus 类**

* 示例：

  * ```c++
    // ch13_09_usebrass1.cpp -- testing bank account classes
    // compile with ch13_09_usebrass1.cpp
    #include <iostream>
    #include "ch13_07_brass.h"
    
    int main()
    {
    	using std::cout;
    	using std::endl;
    
    	Brass Piggy("Porcelot Pigg", 381299, 4000.00);
    	BrassPlus Hoggy("Horatia Hogg", 382288, 3000.00);
    	Piggy.ViewAcct();
    	cout << endl;
    	Hoggy.ViewAcct();
    	cout << endl;
    	cout << "Depositing $1000 into the Hogg Account:\n";
    	Hoggy.Deposit(1000.00);
    	cout << "New balance: $" << Hoggy.Balance() << endl;
    	cout << "Withdrawing $4200 from the Pigg Account:\n";
    	Piggy.Withdraw(4200.00);
    	cout << "Pigg account balance: $" << Piggy.Balance() << endl;
    	cout << "Withdrawing $4200 from the Hogg Account:\n";
    	Hoggy.Withdraw(4200.00);
    	Hoggy.ViewAcct();
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    Client: Porcelot Pigg
    Account Number: 381299
    Balance: $4000.00
    
    Client: Horatia Hogg
    Account Number: 382288
    Balance: $3000.00
    Maximum loan: $500.00
    Owed to bank: $0.00
    Loan Rate: 11.125%
    
    Depositing $1000 into the Hogg Account:
    New balance: $4000
    Withdrawing $4200 from the Pigg Account:
    Withdrawal amount of $4200.00 exceeds your balance.
    Withdrawal canceled.
    Pigg account balance: $4000
    Withdrawing $4200 from the Hogg Account:
    Bank advance: $200.00
    Finance charge: $22.25
    Client: Horatia Hogg
    Account Number: 382288
    Balance: $0.00
    Maximum loan: $500.00
    Owed to bank: $222.25
    Loan Rate: 11.125%
    ```

**3、演示虚方法的行为**

ch13_09_usebrass1.cpp程序清单中，方法是通过对象（而不是指针或引用）调用的，没有使用虚方法特性，下面来使用虚方法：

* 创建指向Brass的指针数组，每个元素的类型都相同，但由于使用的是公有继承模型，因此Brass指针既可以指向Brass对象也可以指向BrassPlus对象。

* 因此，可以使用一个数组来表示多种类型的对象，这就是多态性。

* 示例：

  * ```c++
    // ch13_10_usebrass2.cpp -- polymorphic example
    // compile with ch13_08_brass.cpp
    #include <iostream>
    #include <string>
    #include "ch13_07_brass.h"
    
    const int CLIENTS = 4;
    
    int main()
    {
    	using std::cin;
    	using std::cout;
    	using std::endl;
    
    	Brass* p_clients[CLIENTS];
    	std::string temp;
    	long tempnum;
    	double tempbal;
    	char kind;
    
    	for (int i = 0; i < CLIENTS; i++)
    	{
    		cout << "Enter client's name: ";
    		getline(cin, temp);
    		cout << "Enter client's account number: ";
    		cin >> tempnum;
    		cout << "Enter opening balance: $";
    		cin >> tempbal;
    		cout << "Enter 1 for Brass Account or "
    			<< "2 for BrassPlus Account: ";
    		while (cin >> kind && (kind != '1' && kind != '2'))
    			cout << "Enter either 1 or 2: ";
    		if (kind == '1')
    			p_clients[i] = new Brass(temp, tempnum, tempbal);
    		else
    		{
    			double tmax, trate;
    			cout << "Enter the overdraft limit: $";
    			cin >> tmax;
    			cout << "Enter the interest rate "
    				<< "as a decimal fraction: ";
    			cin >> trate;
    			p_clients[i] = new BrassPlus(temp, tempnum, tempbal,
    										 tmax, trate);
    		}
    		while (cin.get() != '\n')
    			continue;
    	}
    	cout << endl;
    	for (int i = 0; i < CLIENTS; i++)
    	{
    		p_clients[i]->ViewAcct();
    		// 如果数组成员指向的是 Brass 对象，则调用 Brass::ViewAcct();
    		// 如果数组成员指向的是 BrassPlus 对象，则调用 BrassPlus::ViewAcct();
    		// 如果 Brass::ViewAcct() 被声明为虚的，则在任何情况下都将调用 Brass::ViewAcct()。
    		cout << endl;
    	}
    
    	for (int i = 0; i < CLIENTS; i++)
    	{
    		delete p_clients[i];
    	}
    	cout << "Done.\n";
    	return 0;
    }
    ```

    * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/1121fab3-5dc3-4991-a71d-dece265eec3f)
      * 报错原因：两个for循环嵌套在了第一个for循环中，程序崩溃。

* 结果：

  * ```c++
    Enter client's name: Harry Fishsong
    Enter client's account number: 112233
    Enter opening balance: $1500
    Enter 1 for Brass Account or 2 for BrassPlus Account: 1
    Enter client's name: Dinah Otternoe
    Enter client's account number: 121213
    Enter opening balance: $1800
    Enter 1 for Brass Account or 2 for BrassPlus Account: 2
    Enter the overdraft limit: $350
    Enter the interest rate as a decimal fraction: 0.12
    Enter client's name: Brenda Birdherd
    Enter client's account number: 212118
    Enter opening balance: $5200
    Enter 1 for Brass Account or 2 for BrassPlus Account: 2
    Enter the overdraft limit: $800
    Enter the interest rate as a decimal fraction: 0.10
    Enter client's name: Tim Turtletop
    Enter client's account number: 233255
    Enter opening balance: $688
    Enter 1 for Brass Account or 2 for BrassPlus Account: 1
    
    Client: Harry Fishsong
    Account Number: 112233
    Balance: $1500.00
    
    Client: Dinah Otternoe
    Account Number: 121213
    Balance: $1800.00
    Maximum loan: $350.00
    Owed to bank: $0.00
    Loan Rate: 12.000%
    
    Client: Brenda Birdherd
    Account Number: 212118
    Balance: $5200.00
    Maximum loan: $800.00
    Owed to bank: $0.00
    Loan Rate: 10.000%
    
    Client: Tim Turtletop
    Account Number: 233255
    Balance: $688.00
    
    Done.
    ```



**4、为何需要析构函数**

在上述程序清单中，使用 delete 释放由 new 分配的对象代码说明了为何基类应包含一个虚析构函数：

* 如果析构函数不是虚的，则将只调用对应于指针类型的析构函数。对于程序清单13.10这意味着只有 Brass 的析构函数被调用，即使指针指的是一个 BrassPlus对象。
* 如果析构数是虚的，将调用相应对象类型的析构函数。
* 因此，如果指针指的是 BrassPlus 对象，将调用 BrassPlus 的析构函数，然后自动调用基类的析构函数。

因此，使用虚析构函数可以确保正确的析构函数序列被调用。

对于程序清单 13.10，这种正确的行为并不是很重要，因为析构函数没有执行任何操作。然而，如果 BrassPlus 包含一个执行某些操作的析构函数，则 Brass 必须有一个虚析构函数，即使该析构函数不执行任何操作。



### 13.4 静态联编和动态联编

将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编，在C++中，由于函数重载的缘故，这项任务更加复杂。然而C/C++编译器可以在编译过程中完成这种联编。

* 静态联编（早期联编）：在编译过程中进行联编；
* 动态联编（晚期联编）：编译器必须生成能能够在程序运行时选择正确的虚方法的代码。



#### 13.4.1 指针和引用类型的兼容性

在 C++中，动态联编与通过指针和引用调用方法相关，从某种程度上说，这是由继承控制的。

* 将派生类引用或指针转换为基类引用或指针被称为向上强制转换（upcasting），这使公有继承不需要进行显式类型转换。该规则是 is-a 关系的一部分。

* 相反的过程——将基类指针或引用转换为派生类指针或引用——称为向下强制转换。如果不使用显式类型转换，则向下强制转换是不允许的。原因是 is-a 关系通常是不可逆的。

* 派生类可以新增数据成员，因此使用这些数据成员的类成员函数不能应用于基类。

* 对于使用基类引用或指针作为参数的函数调用，将进行向上转换。请看下面的代码段，这里假定每个函数都调用虚方法ViewAcct()：

  * ```c++
    void fr(Brass & rb);	// user rb.ViewAcct()
    void fp(Brass * pd);	// uses pb->ViewAcct()
    void fv(Brass b);		//uses b.ViewAcct()
    int main()
    {
        Brass b("Billy Bee", 123432, 10000.0);
        BrassPlus bp("Betty Beep", 232313, 123456.0);
        fr(b);		// uses Brass::ViewAcct()
        fr(bp);		// uses BrassPlus::ViewAcct()
        fp(b);		// uses Brass::ViewAcct()
        fp(bp);		// uses BrassPlus::ViewAcct()
        fv(b);		// uses Brass::ViewAcct()
        fv(bp);		// uses Brass::ViewAcct()
        ...
    }
    ```

  * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/e451bc5c-a12b-4ad6-973e-49655e6c64bc)

  * 按值传递导致只将 BrassPlus 对象的 Brass 部分传递给函数 fv()。

  * 但随引用和指针发生的隐式向上转换导致函数fr()和fp()分别为 Brass 对象和 BrassPlus 对象使用 Brass::ViewAcct() 和 BrassPlus::ViewAcct()。

* 隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编。C++使用虚成员函数来满足这种需求。



#### 13.4.2 虚成员函数和动态联编

* ```c++
  BrassPlus ophelia;	// derived-class object
  Brass * bp;		    // base-class pointer
  bp = &ophelia;		// Brass pointer to BrassPlus object
  bp->ViewAcct();		// which version?
  ```

* 如果在基类中没有将 ViewAcct() 声明为虚的，则 bp->ViewAcct(); 将根据指针类型（Brass *）调用 Brass::ViewAcct()。

  * 总之，编译器对非虚方法使用静态联编。

* 如果在基类中将 ViewAcct() 声明为虚的，则 bp->ViewAcct(); 根据对象类型（BrassPlus）调用 BrassPlus::ViewAcct()。

  * 总之，编译器对虚方法使用动态联编。

**1、为什么有两种类型的联编以及为什么默认为静态联编**

* 原因：效率和概念模型
  * 静态联编的效率更高，为使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，这增加了额外的处理开销。
    * 例如，如果类不会用作基类，则不需要动态联编。
    * 同样，如果派生类不重新定义基类的任何方法，也不需要使用动态联编。
  * 概念模型，在设计类时，可能包含一些不在派生类重新定义的成员函数，不将该函数设置为虚函数不仅效率更高，而且指出不要重新定义该函数。
    * 这表明，仅将那些预期将被重新定义的方法声明为虚的。
* 📌如果要在派生类中重新定义基类的方法，则将它设置为虚方法；否则，设置为非虚方法。

**2、虚函数的工作原理**

![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/842897ef-0b4a-4bd4-bdf5-32186d73d9f8)

总之，使用虚函数时，在内存和执行速度方面有一定的成本，包括：

* 每个对象都将增大，增大量为存储地址的空间；
* 对于每个类，编译器都创建一个虚函数地址表（数组）；
* 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。

虽然非虚函数的效率比虚函数稍高，但不具备动态联编功能。



#### 13.4.3 有关虚函数注意事项

虚函数要点：

* 在基类方法的声明中使用关键字 virtual 可使该方法在基类以及所有的派生类（包括从派生类派生出来的类）中是虚的。
* 如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为**动态联编**或晚期联编。这种行为非常重要，因为这样基类指针或引用可以指向派生类对象。
* 如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的。

**1、构造函数：**

* 构造函数不能是虚函数，派生类不继承基类的构造函数，所以将类构造函数声明为虚的没意义。

**2、析构函数：**

* 析构函数应当是虚函数，除非类不用做基类。
* 通常应给基类提供一个虚析构函数，即使它并不需要析构函数。

**3、友元：**

* 友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数。

**4、没有重新定义：**

* 如果派生类没有重新定义函数，将使用该函数的基类版本；
* 如果派生类位于派生链中，则将使用最新的虚函数版本；
* 例外的情况是基类版本是隐藏的（稍后将介绍）。

**5、重新定义将隐藏方法：**

* 重新定义不会生成函数的两个重载版本，而是隐藏了基类版本。
  * 总之，重新定义继承的方法并不是重载。
  * 如果在派生类中重新定义函数，将不是使用相同的函数特征标覆盖基类声明，而是隐藏同名的基类方法，不管参数特征标如何。
* 两条经验规则：
  * 如果重新定义继承的方法，应确保与原来的原型完全相同.
    * 但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针（这种例外是新出现的）。
      * 这种特性被称为返回类型协变（covariance ofreturn type），因为允许返回类型随类类型的变化而变化：P506
      * 这种例外只适用于返回值，而不适用于参数。
  * 如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。



### 13.5 访问控制：protected

除了 public 和 private 来控制对类成员的访问，还存在另一个访问类别：protected **保护成员**（与private相似，在类外只能用公有类成员来访问 protected 部分中的类成员）。

private 和 protected 之间的区别只有在基类派生的类中得以表现：

* 派生类成员可以之间访问基类的保护成员，但不能直接访问基类的私有成员。
* 因此，对于外部世界来说，**保护成员**的行为与私有成员相似；
* 但对于派生类来说，**保护成员**的行为与公有成员相似。
* 见P507-508

❗警告：最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据。

然而，对于成员函数来说，保护访问控制很有用，它让派生类能够访问公众不能使用的内部函数。



### 13.6 抽象基类

示例：开发图形程序，显示圆和椭圆（圆是椭圆的一种特殊情况），可以从 Ellipse 类派生出 Circle 类，但是涉及到椭圆面积，移动椭圆等操作方法时，对圆来说并不适用。

* 总之，不适用继承，直接定义 Circle 类更简单；
* 解决方法：
  * 从 Ellipse 和 Circle 类中抽象出它们的共性，将这些特性放到一个抽象基类中（ABC）。
  * 然后，从该ABC派生出 Circle 和 Ellipse 类。
  * 这样便可以使用基类指针数组同时管理 Circle 和 Ellipse 对象。

C++通过使用**纯虚函数**提供为实现的函数。纯虚函数声明的结尾处为 =0，参见P509的 Area()方法：

* ```c++
  virtual double Area() const = 0;
  ```

* 总之，在原型中使用 =0 指出类是一个抽象基类，在类中可以不定义该函数。

现在，可以从 BaseEllipse 类派生出 Ellips 类和 Cirle 类，添加所需的成员来完成每个类。见P510。

* 使用这些类的程序将能够创建 Ellipse 对象和 Circle 对象，但是不能创建 BaseEllipse 对象。

📌总之，ABC 描述的是至少使用一个纯虚函数的接口，从 ABC 派生出的类将根据派生类的具体特征，使用常规虚函数来实现这种接口。



#### 13.6.1 应用 ABC 概念

首先定义一个名为 AcctABC 的 ABC。这个**抽象基类**包含 Brass 和 BrassPlus 类公有的所有方法和数据成员，而那些在 BrassPluss 和 Brass 类中的行为不同的方法应被声明为虚函数。<u>至少应有一个虚函数是纯虚函数，这样才能使 AcctABC 称为抽象类。</u>

程序清单：

* 示例：

  * ```c++
    #pragma once
    // ch13_11_acctabc.h -- bank account classes
    #ifndef CH13_11_ACCTABC_H_
    #define CH13_11_ACCTABC_H_
    #include <iostream>
    #include <string>
    
    // Abstract Base Class
    class AcctABC
    {
    private:
    	std::string fullName;
    	long acctNum;
    	double balance;
    protected:
    	struct Formatting
    	{
    		std::ios_base::fmtflags flag;
    		std::streamsize pr;
    	};
    	const std::string& FullName() const { return fullName; }
    	long AcctNum() const { return acctNum; }
    	Formatting SetFormat() const;
    	void Restore(Formatting& f) const;
    public:
    	AcctABC(const std::string& s = "Nullbody", long an = -1,
    			double bal = 0.0);
    	void Deposit(double amt);
    	virtual void Withdraw(double amt) = 0;
    	double Balance() const { return balance; };
    	virtual void ViewAcct() const = 0;
    	virtual ~AcctABC() {}
    };
    
    // Brass Account Class
    class Brass : public AcctABC
    {
    public:
    	Brass(const std::string & s = "Nullbody", long an = -1,
    		double bal = 0.0) : AcctABC(s, an, bal) { }
    	virtual void Withdraw(double amt);
    	virtual void ViewAcct() const;
    	virtual ~Brass() {}
    };
    
    // Brass Plus Account Class
    class BrassPlus : public AcctABC
    {
    private:
    	double maxLoan;
    	double rate;
    	double owesBank;
    public:
    	BrassPlus(const std::string& s = "Nullbody", long an = -1,
    			double bal = 0.0, double ml = 500, double r = 0.10);
    	BrassPlus(const Brass& ba, double ml = 500, double r = 0.1);
    	virtual void ViewAcct() const;
    	virtual void Withdraw(double amt);
    	void ResetMax(double m) { maxLoan = m; }
    	void ResetRate(double r) { rate = r; }
    	void ResetOwes() { owesBank = 0; }
    };
    
    #endif
    ```

  * ```c++
    // ch13_12_acctabc.cpp -- bank account class methods
    #include <iostream>
    #include "ch13_11_acctabc.h"
    using std::cout;
    using std::ios_base;
    using std::endl;
    using std::string;
    
    // Abstract Base Class
    AcctABC::AcctABC(const string& s, long an, double bal)
    {
    	fullName = s;
    	acctNum = an;
    	balance = bal;
    }
    
    void AcctABC::Deposit(double amt)
    {
    	if (amt < 0)
    		cout << "Negative deposit not allowed; "
    		<< "deposit is cancelled.\n";
    	else
    		balance += amt;
    }
    
    void AcctABC::Withdraw(double amt)
    {
    	balance -= amt;
    }
    
    // protected methods for formatting
    AcctABC::Formatting AcctABC::SetFormat() const
    {
    // set up ###.## format
    	Formatting f;
    	f.flag = cout.setf(ios_base::fixed, ios_base::floatfield);
    	f.pr = cout.precision(2);
    	return f;
    }
    
    void AcctABC::Restore(Formatting& f) const
    {
    	cout.setf(f.flag, ios_base::floatfield);
    	cout.precision(f.pr);
    }
    
    // Brass methods
    void Brass::Withdraw(double amt)
    {
    	if (amt < 0)
    		cout << "Withdrawal amount must be positive; "
    		<< "withdrawal canceled.\n";
    	else if (amt <= Balance())
    		AcctABC::Withdraw(amt);
    	else
    		cout << "Withdrawal amount of $" << amt
    		<< " exceeds your balance.\n"
    		<< "Withdrawal canceled.\n";
    }
    
    void Brass::ViewAcct() const
    {
    	Formatting f = SetFormat();
    	cout << "Brass Client: " << FullName() << endl;
    	cout << "Account Number: " << AcctNum() << endl;
    	cout << "Balance: $" << Balance() << endl;
    	Restore(f);
    }
    
    // BrassPlus Methods
    BrassPlus::BrassPlus(const string& s, long an, double bal,
    	double ml, double r) : AcctABC(s, an, bal)
    {
    	maxLoan = ml;
    	owesBank = 0.0;
    	rate = r;
    }
    
    BrassPlus::BrassPlus(const Brass& ba, double ml, double r)
    	: AcctABC(ba)	// uses implicit copy constructor
    {
    	maxLoan = ml;
    	owesBank = 0.0;
    	rate = r;
    }
    
    void BrassPlus::ViewAcct() const
    {
    	Formatting f = SetFormat();
    
    	cout << "BrassPlus Clien: " << FullName() << endl;
    	cout << "Account Number: " << AcctNum() << endl;
    	cout << "Balance: $" << Balance() << endl;
    	cout << "Maximum loan: $" << maxLoan << endl;
    	cout << "Owed to bank: $" << owesBank << endl;
    	cout.precision(3);
    	cout << "Loan Rate: " << 100 * rate << "%\n";
    	Restore(f);
    }
    
    void BrassPlus::Withdraw(double amt)
    {
    	Formatting f = SetFormat();
    
    	double bal = Balance();
    	if (amt <= bal)
    		AcctABC::Withdraw(amt);
    	else if (amt <= bal + maxLoan - owesBank)
    	{
    		double advance = amt - bal;
    		owesBank += advance * (1.0 + rate);
    		cout << "Bank advance: $" << advance << endl;
    		cout << "Finance charge: $" << advance * rate << endl;
    		Deposit(advance);
    		AcctABC::Withdraw(amt);
    	}
    	else cout << "Credit limit exceeded. Transaction cancelled.\n";
    	Restore(f);
    }
    ```

    * 对于输出格式，这一版本定义了一个结构，用于存储两项格式设置；并使用该结构来设置和恢复格式，因此只需要两个函数调用。
      * 由于该示例探讨保护访问权限，因此将这些函数以及结构放在了类定义的保护部分。这使得它们对基类和派生类可用，同时向外隐藏了它们。

  * ```c++
    // ch13_13_usebrass3.cpp -- polymorphic example
    // compile with  ch13_12_acctabc.cpp
    #include <iostream>
    #include <string>
    #include "ch13_11_acctabc.h"
    
    const int CLIENTS = 4;
    
    int main()
    {
    	using std::cin;
    	using std::cout;
    	using std::endl;
    
    	AcctABC* p_clients[CLIENTS];
    	std::string temp;
    	long tempnum;
    	double tempbal;
    	char kind;
    
    	for (int i = 0; i < CLIENTS; i++)
    	{
    		cout << "Enter client's name: ";
    		getline(cin, temp);
    		cout << "Enter client's account number: ";
    		cin >> tempnum;
    		cout << "Enter opening balance: $";
    		cin >> tempbal;
    		cout << "Enter 1 for Brass Account or "
    			<< "2 for BrassPlus Account: ";
    		while (cin >> kind && (kind != '1' && kind != '2'))
    			cout << "Enter either 1 or 2: ";
    		if (kind == '1')
    			p_clients[i] = new Brass(temp, tempnum, tempbal);
    		else
    		{
    			double tmax, trate;
    			cout << "Enter the overdraft limit: $";
    			cin >> tmax;
    			cout << "Enter the interest rate "
    				<< "as a decimal fraction: ";
    			cin >> trate;
    			p_clients[i] = new BrassPlus(temp, tempnum, tempbal,
    										 tmax, trate);
    		}
    		while (cin.get() != '\n')
    			continue;
    	}
    	cout << endl;
    	for (int i = 0; i < CLIENTS; i++)
    	{
    		p_clients[i]->ViewAcct();
    		// 如果数组成员指向的是 Brass 对象，则调用 Brass::ViewAcct();
    		// 如果数组成员指向的是 BrassPlus 对象，则调用 BrassPlus::ViewAcct();
    		// 如果 Brass::ViewAcct() 被声明为虚的，则在任何情况下都将调用 Brass::ViewAcct()。
    		cout << endl;
    	}
    
    	for (int i = 0; i < CLIENTS; i++)
    	{
    		delete p_clients[i];
    	}
    	cout << "Done.\n";
    	return 0;
    }
    ```

* 结果：

  * ```c++
    Enter client's name: Harry Fishsong
    Enter client's account number: 112233
    Enter opening balance: $1500
    Enter 1 for Brass Account or 2 for BrassPlus Account: 1
    Enter client's name: Dinah Otternoe
    Enter client's account number: 121213
    Enter opening balance: $1800
    Enter 1 for Brass Account or 2 for BrassPlus Account: 2
    Enter the overdraft limit: $350
    Enter the interest rate as a decimal fraction: 0.12
    Enter client's name: Brenda Birdherd
    Enter client's account number: 212118
    Enter opening balance: $5200
    Enter 1 for Brass Account or 2 for BrassPlus Account: 2
    Enter the overdraft limit: $800
    Enter the interest rate as a decimal fraction: 0.10
    Enter client's name: Tim Turtletop
    Enter client's account number: 233255
    Enter opening balance: $688
    Enter 1 for Brass Account or 2 for BrassPlus Account: 1
    
    Brass Client: Harry Fishsong
    Account Number: 112233
    Balance: $1500.00
    
    BrassPlus Clien: Dinah Otternoe
    Account Number: 121213
    Balance: $1800.00
    Maximum loan: $350.00
    Owed to bank: $0.00
    Loan Rate: 12.000%
    
    BrassPlus Clien: Brenda Birdherd
    Account Number: 212118
    Balance: $5200.00
    Maximum loan: $800.00
    Owed to bank: $0.00
    Loan Rate: 10.000%
    
    Brass Client: Tim Turtletop
    Account Number: 233255
    Balance: $688.00
    
    Done.
    ```



#### 13.6.2 ABC 理念

设计 ABC 之前，首先应开发一个模型——指出编程问题所需的类以及它们之间相互关系。

可以将 ABC 看作是一种必须实施的接口。ABC 要求具体派生类覆盖其纯虚函数——迫使派生类遵循ABC 设置的接口规则。在这种情况下，使用 ABC 使得组件设计人员能够制定“接口约定”，这样确保了从ABC 派生的所有组件都至少支持 ABC 指定的功能。



### 13.7 继承和动态内存分配

继承与动态内存分配（new 和 delete）互动，如果基类使用动态内存分配，并重新定义赋值和复制构造函数，那么派生类的实现将取决于派生类的属性。如果派生类也是用动态内存分配，那么就需要注意下面两种情况：



#### 13.7.1 第一种情况：派生类不使用 new

假设基类使用了动态内存分配：

* ```c++
  // Bass Class Using DMA
  class baseDMA
  {
  private:
      char * label;
      int rating;
  public:
      baseDMA(const char * 1 = "null", int r = 0);
      baseDMA(const baseDMA & rs);
      virtual ~baseDMA();
      baseDMA & operator=(const baseDMA & rs);
      ...
  };
  ```

  * 声明中包含了**构造函数使用 new 时需要的特殊方法**：<u>析构函数</u>、<u>复制构造函数</u>和<u>重载赋值运算符</u>。

现在从基类 baseDMA 中派生出 lackDMA 类，而后者不适用new，也未包含其他一些不常用的、需要特殊处理的设计特性：

* ```c++
  // derived class without DMA
  class lacksDMA : public baseDMA
  {
  private:
      char color[40];
  public:
      ...
  };
  ```

* ❗不需要为派生类 lackDMA 类定义显示析构函数、复制构造函数和赋值运算符。见P517

  * 派生类对象的这些属性也适用于本身死对象的类成员。



#### 13.7.2 第二种情况：派生类使用 new

假设基类使用了 new：

* ```c++
  // derived class with DMA
  class hasDMA : public baseDMA
  {
  private:
      char * style;	// use new in constructors
  public:
      ...
  };
  ```

  * 在这种情况下，必须为派生类定义显式析构函数、复制构造函数和赋值运算符

* 析构函数：

  * 派生类析构函数自动调用基类的析构函数，故其自身的职责是对派生类构造函数执行工作的进行清理。因此 hasDMA 析构函数必须释放指针 style 管理的内存并依赖于 baseDMA 的析构函数来释放指针 label 管理的内存。

    * ```c++
      baseDMA::~baseDMA()
      {
          delete [] label;
      }
      
      hasDMA::~hasDMA()
      {
          delete [] style;
      }
      ```

* 复制构造函数：

  * BaseDMA的复制构造函数遵循用于 char 数组的常规模式，即使用 strlen() 来获悉存储C-风格字符串所需的空间、分配足够的内存(字符数加上存储空字符所需的1字节)并使用函数strcpy()将原始字符串复制到目的地：

    * ```c++
      baseDMA::baseDMA(const baseDMA & rs)
      {
          label = new char[std::strlen(re.label) + 1];
          std::strcpy(label, rs.label);
          rating = rs.rating;
      }
      ```

  * hasDMA 复制构造函数只能访问 hasDMA 的数据因此它必须调用 baseDMA 复制构造函数来处理共享的 baseDMA 数据：

    * ```c++
      hasDMA::hasDMA(const hasDMA & hs) : baseDMA(hs)
      {
          style = new char[std::strlen(hs.style) + 1];
          std::strcpy(style, hs.style);
      }
      ```

* 赋值运算符：

  * baseDMA赋值运算符遵循如下常规格式：

    * ```c++
      baseDMA & baseDMA::operator=(const baseDMA & rs)
      {
          if (this == &rs)
              return *this;
          delete [] label;
          label = new chat[std::strlen(rs.label) + 1];
          std::strcpy(label, rs.label);
          rating = rs.rating;
          return * this;
      }
      ```

  * 由于 hasDMA 也使用动态内存分配，所以它也需要一个显式赋值运算符。作为 hasDMA 的方法，它只能直接访问 hasDMA 的数据。然而，派生类的显式赋值运算符必须负责所有继承的 baseDMA 基类对象的赋值，可以通过显式调用基类赋值运算符来完成这项工作，如下所示：

    * ```c++
      hasDMA & hasDMA::operator=(const hasDMA & hs)
      {
          if (this == &hs)
              return *this;
          baseDMA::operator=(hs);
          delete [] style;
          style = new char[std::strlen(hs.style) + 1];
          std::strcpy(style, hs.style);
          return *this;
      }
      ```

      * baseDMA::operator=(hs); 通过使用函数表示法，而不是运算符表示法，可以使用作用域解析运算符。该语句含义是：*this = hs; 
      * 编译器将使用hasDMA::operator=()，从而形成递归调用。使用函数表示法使得赋值运算符被正确调用。

总之，当**基类和派生类**都采用**动态内存分配**时，派生类的析构函数、复制构造函数、赋值运算符都**必须使用相应**的基类方法来处理基类元素。

这种要求是通过三种不同的方式来满足的：

* 对于析构函数，这是自动完成的；
* 对于构造函数，这是通过在初始化成员列表中调用基类的复制构造函数来完成的；如果不这样做，将自动调用基类的默认构造函数。
* 对于赋值运算符，这是通过使用作用域解析运算符显式地调用基类的赋值运算符来完成的。



#### 13.7.3 使用动态内存分配和友元的继承示例
