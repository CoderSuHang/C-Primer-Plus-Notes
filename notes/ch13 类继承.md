## 第十三章 类继承

面向对象编程的主要目的之一是提供可重用的代码。开发新项目，尤其是当项目十分庞大时，重用经过测试的代码比重新编写代码要好得多。使用已有的代码可以节省时间，由于已有的代码已被使用和测试过，因此有助于避免在程序中引入错误。另外，必须考虑的细节越少，便越能专注于程序的整体策略。

C++提供了比修改代码更好的方法来扩展和修改类。这种方法叫作类继承，它能够从已有的类派生出新的类，而派生类继承了原有类（称为基类）的特征，包括方法。

* 可以在已有类的基础上添加功能。例如，对于数组类，可以添加数学运算。
* 可以给类添加数据。例如，对于字符串类，可以派生出一个类，并添加指定字符串显示颜色的数据成员。
* 可以修改类方法的行为。例如，对于代表提供给飞机乘客的服务的 Passenger 类可以派生出提供更高级别服务的FirstClassPassenger 类。

当然，可以通过复制原始类代码，并对其进行修改来完成上述工作，但继承机制只需提供新特性，甚至不需要访问源代码就可以派生出类。

### 13.1 一个简单的基类

从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。

* 1、基类：

  * 以Webtown俱乐部决定跟踪乒乓球会会员为例，设计一个简单的 TableTennisPlayer 类。

  * TableTennisPlayer 类只是记录会员的姓名以及是否有球桌。

    * ```c++
      #pragma once
      // ch13_01_tabtenn0.h -- a table-tennis base class
      #ifndef CH13_01_TABTENN0_H_
      #define CH13_01_TABTENN0_H_
      #include <string>
      
      using std::string;
      // simple base class
      class TableTennisPlayer
      {
      private:
      	string firstname;
      	string lastname;
      	bool hasTable;
      public:
      	TableTennisPlayer(const string& fn = "none", const string& ln = "none", bool ht = false);
      	void Name() const;
      	bool HasTable() const { return hasTable; };
      	void ResetTable(bool v) { hasTable = v; };
      };
      #endif
      ```

    * ```c++
      // ch13_02_tabtenn0.cpp -- simple base-class method
      #include "ch13_01_tabtenn0.h"
      #include <iostream>
      
      TableTennisPlayer::TableTennisPlayer(const string & fn, 
      	const string & ln, bool ht) : firstname(fn), 
      	lastname(ln), hasTable(ht) {}
      
      void TableTennisPlayer::Name() const
      {
      	std::cout << lastname << ", " << firstname;
      }
      ```

      * 其中ch13_02_tabtenn0.cpp使用了第12章介绍的成员初始化列表语法，等价于下面内容：

        * ```c++
          TableTennisPlayer::TableTennisPlayer(const string & fn, 
          	const string & ln, bool ht)
          {
          	firstname = fn; 
          	lastname = ln;
              hasTable = ht;
          }
          ```

        * 详细步骤是：

          * 这将首先为 firstname 调用 string 的默认构造函数，再调用 string 的赋值运算符将 firstname 设置为 fn，
          * 但初始化列表语法可减少一个步骤，它直接使用 string 的复制构造函数将 firstname 初始化为 fn

    * ```c++
      // ch13_03_usett0.cpp -- using a base class
      #include <iostream>
      #include "ch13_01_tabtenn0.h"
      
      int main(void)
      {
      	using std::cout;
      	TableTennisPlayer player1("Chuck", "Blizzard", true);
      	TableTennisPlayer player2("Tara", "Boomdea", false);
      
      	player1.Name();
      	if (player1.HasTable())
      		cout << ": has a table.\n";
      	else
      		cout << ": hasn't a table.\n";
      
      	player2.Name();
      	if (player2.HasTable())
      		cout << ": has a table.\n";
      	else
      		cout << ": hasn't a table.\n";
      
      	return 0;
      }
      ```

  * 结果：

    * ```c++
      Blizzard, Chuck: has a table.
      Boomdea, Tara: hasn't a table.
      ```

    * 注意到该程序实例化对象时将 C-风格字符串作为参数：

      * ```c++
        TableTennisPlayer player1("Chuck", "Blizzard", true);
        TableTennisPlayer player2("Tara", "Boomdea", false);
        ```

      * 但构造函数的形参类型被声明为 const string &。这导致类型不匹配，但与第12章创建的 String 类一样，string 类有一个将 const char * 作为参数的构造函数，使用C-风格字符串初始化 string 对象时，将自动调用这个构造函数。

      * 总之，**可将 string 对象或C-风格字符串作为构造函数 TableTennisPlayer 的参数**：

        * 将前者作为参数时，将调用接受 const string & 作为参数的 string 构造函数；
        * 而将后者作为参数时，将调用接受 const char* 作为参数的 string 构造函数。

#### 13.1.1 派生一个类

Webtown 俱乐部的一些成员**曾经**参加过当地的乒乓球锦标赛：需要这样一个类，它能包括成员在比赛中的比分。

* 与其从零开始，不如从 TableTennisClass 类派生出一个类。首先将 RatedPlayer 类声明为从 TableTennisClass 类派生而来：

  * ```c++
    // RatedPlayer derives from the TableTennisPlayer base class
    class RatedPlayer : public TableTennisPlayer
    {
    ...
    };
    ```

  * 冒号指出 RatedPlayer 类的基类是 public TableTennisPlayer 类。

  * “class RatedPlayer : public TableTennisPlayer”特殊的声明头表明 TableTennisPlayer 是一个公有基类，这被称为公有派生。

    * 派生类对象包含基类对象；
    * 使用公有派生：
      * 基类的公有成员将成为派生类的共有成员；
      * 基类的私有部分称为派生类的一部分，但只能通过基类的公有和保护方法访问。

  * RatedPlayer 对象将具有以下特征：

    * 派生类对象储存了基类的数据成员（派生类继承了基类的实现）；
    * 派生类对象可以使用基类的方法（派生类继承了基类的接口）。
    * 因此，RatedPlayer 对象可以储存运动员的姓名及其是否有球桌，另外还可以使用 T 类的Name()、hasTable()、ResetTable()方法：
      * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/3dc3f49a-a1a3-490d-9ed5-5ecbb3b498fe)

  * 需要再继承特性中添加什么呢：

    * 派生类需要自己的构造函数。

    * 派生类可以根据需要添加额外的数据成员和成员函数。

    * 在这个例子中，派生类需要另一个数据成员来存储比分，还应包含检索比分的方法和重置比分的方法。因此，类声明与下面类似：

      * ```c++
        // simple detived class
        class RatedPlayer : public TableTennisPlayer
        {
        private:
            unsigned int rating;	// add a data member
        public:
            RatedPlayer (unsigned int r = 0, const string & fn = "none", const string& ln = "none", bool ht = false);
            RatedPlayer (unsigned int r, const TableTennisPlayer & tp);
            unsigned int Rating () const { return rating; }		// add a method
            void ResetRating (unsigned int r) { rating = r; }	// add a method
        };
        ```

#### 13.1.2 构造函数：访问权限的考虑

📌派生类不能直接访问基类的私有成员，而必须通过基类方进行访问。具体地说，派生类构造函数必须使用基类构造函数。

创建派生对象时，程序首先创建基类对象：

* ```c++
  RatedPlayer::RatedPlayer(unsigned int r, const string & fn,
                          const string & ln, bool ht) : TableTennisPlayer(fn, 
                          ln, ht)
  {
      rating = r;
  }
  ```

* 其中：**TableTennisPlayer (fn, ln, ht) 是成员初始化列表**。它是可执行的代码，调用TableTennisPlayer构造函数：

  * ```C++
    RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
    ```

    * RatedPlayer构造函数将把实参（"Mallory", "Duck", true）赋给形参（fn, ln, ht）
    * 然后将这些参数作为实参传递给TableTennisPlayer构造函数，该函数将创建一个嵌套TableTennisPlayer对象，并将数据（"Mallory", "Duck", true）存储在该对象中。
    * 最后，程序进入RatedPlayer构造函数构造函数体，完成RealPlayer对象的创建，并将参数的 r 值（1140）赋给rating成员：
      * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/24b7d846-aaf7-447f-b044-20ad6e2dc6c2)


  * 如果省略成员初始化列表，程序会使用默认的基类构造函数进行创建基类对象，见P485

* 如果愿意，也可以对派生类成员使用成员初始化列表语法。在这种情况下，应在列表中使用**成员名**，而不是类名。所以，第二个构造函数可以按照下述方式编写：

  * ```c++
    // alternative version
    RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer & tp)
        : TableTennisPlayer(tp), rating(r)
        {
        }
    ```

* 有关派生类构造函数的要点如下：

  * 首先创建基类对象；
  * 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；
  * 派生类构造函数应初始化派生类新增的数据成员。

* 创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数：

  * 基类构造函数负责初始化继承的数据成员；
  * 派生类构造函数主要用于初始化新增的数据成员。
    * 派生类的构造函数总是调用一个基类构造函数。可以使用初始化器列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。
    * 派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。

📌成员初始化列表：

* 派生类构造函数可以使用初始化器列表机制将值传递给基类构造函数：

  * ```c++
    derived::derived(type1 x, type2 y) : base(x, y)
    {
        ...
    }
    ```

  * 其中 derived 是派生类，base 是基类，x和y是基类构造函数使用的变量。

  * 如果没有在成员初始化列表中提供基类构造函数，程序将使用默认的基类构造函数。成员初始化列表只能用于构造函数。



#### 13.1.3 使用派生类

要使用派生类，程序必须要**能够访问基类声明**。程序清单 13.4 将这**两种类**的**声明**置于**同一个头文件**中。也可以将每个类放在独立的头文件中，但由于这两个类是相关的，所以把其类声明放在一起更合适。

* 示例：

  * ```c++
    #pragma once
    // ch13_04_tabtenn1.h -- a table-tennis base class
    #ifndef CH13_04_TABTENN1_H_
    #define CH13_04_TABTENN1_H_
    #include<string>
    using std::string;
    // simple base class
    class TableTennisPlayer
    {
    private:
    	string firstname;
    	string lastname;
    	bool hasTable;
    public:
    	TableTennisPlayer(const string& fn = "none",
    					  const string& ln = "none", bool ht = false);
    	void Name() const;
    	bool HasTable() const { return hasTable; };
    	void ResetTable(bool v) { hasTable = v; };
    };
    
    // simple derived class
    class RatedPlayer : public TableTennisPlayer
    {
    private:
    	unsigned int rating;
    public:
    	RatedPlayer(unsigned int r = 0, const string& fn = "none",
    				const string& ln = "none", bool ht = false);
    	RatedPlayer(unsigned int r, const TableTennisPlayer& tp);
    	unsigned int Rating() const { return rating; }
    	void ResetRating(unsigned int r) { rating = r; }
    };
    #endif
    ```

  * ```c++
    // ch13_05_tabtenn1.cpp -- simple base-class methods
    #include "ch13_04_tabtenn1.h"
    #include <iostream>
    
    TableTennisPlayer::TableTennisPlayer (const string & fn,
    	const string & ln, bool ht) : firstname(fn),
    	lastname(ln), hasTable(ht) {}
    
    void TableTennisPlayer::Name() const
    {
    	std::cout << lastname << ", " << firstname;
    }
    
    // RatedPlayer methods
    RatedPlayer::RatedPlayer (unsigned int r, const string& fn,
    	const string& ln, bool ht) : TableTennisPlayer(fn, ln, ht)
    {
    	rating = r;
    }
    
    RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer& tp)
    	: TableTennisPlayer(tp), rating(r)
    {
    }
    ```

  * ```c++
    // ch13_06_usett1.cpp -- using base class and derived class
    #include <iostream>
    #include "ch13_04_tabtenn1.h"
    
    int main(void)
    {
    	using std::cout;
    	using std::endl;
    	TableTennisPlayer player1("Tara", "Boomdea", false);
    	RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
    	rplayer1.Name();
    	if (rplayer1.HasTable())
    		cout << ": has a table.\n";
    	else
    		cout << ": hasn't a table.\n";
    	player1.Name();
    	if (player1.HasTable())
    		cout << ": has a table\n";
    	else
    		cout << ": hasn't a table.\n";
    	cout << "Name: ";
    	rplayer1.Name();
    	cout << "; Rating: " << rplayer1.Rating() << endl;
    	RatedPlayer rplayer2(1212, player1);
    	cout << "Name: ";
    	rplayer2.Name();
    	cout << "; Rating: " << rplayer2.Rating() << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    Duck, Mallory: has a table.
    Boomdea, Tara: hasn't a table.
    Name: Duck, Mallory; Rating: 1140
    Name: Boomdea, Tara; Rating: 1212
    ```



#### 13.1.4 派生类和基类之间的特殊关系

（1）派生类对象可以使用基类的方法，条件是方法不是私有的；

* ```c++
  RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
  rplayer1.Name();
  ```

（2）基类指针可以在不进行显式类型转换的情况下指向派生类对象；

* ```c++
  RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
  TableTennisPlayer * pt = &rplayer;
  py->Name();
  ```

（3）基类应用可以在不进行显式类型转换的情况下引用派生类对象/

* ```c++
  RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
  TableTennisPlayer & rt = rplayer;
  rt.Name();
  ```

❗基类**指针**或**引用**只能调用基类方法，因此，不能使用rt或pt来调用派生类的ResetRanking方法。

❗可以将派生类对象和地址赋给基类应用和指针。（包含关系）

* 通常，C++要求引用和指针类型与赋给的类型匹配，但这一规则对**继承**来说是例外。然而，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针。
* 代码见P488，这一部分很深奥，在后续应用过程中可以反复翻阅查看



### 13.2 继承：is-a关系

派生类和基类之间的特殊关系是基于C++继承的底层模型。实际上C++有3种继承方式：（公有继承、保护继承、私有继承）

* 公有继承：
  * is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行。
    * 与该模型不符的例子：P490
      * has-a关系
      * is-like-a关系
      * is-implemented-as-a关系
      * use-a关系



### 13.3 多态公有继承

多态：具有多种形态的复杂行为，即方法的行为应取决于调用该方法的对象。

* 之前讲述的继承很简单，派生类对象使用基类的方法，而未做任何改变。然而，可能会遇到这样的情况，即希望同一个方法在派生类的和基类种的行为是不同的。

用于实现多态公有继承的两种重要机制：

* 在派生类种重新定义基类的方法；
* 使用虚方法。

示例：创建两个类

* 1、用于表示基本支票账户——Brass Account
* 2、调价了透支保护性的支票保护——Brass Plus

从Brass公有类派生出BrassPlus，并且BrassPlus类满足is-a条件（is-a关系通常不可逆：水果不是香蕉，同样，Brass对象不具备BrassPlus对象的所有功能。

#### 13.3.1 开发Brass类和BrassPlus类

见P491

* 示例：

  * ```c++
    //ch13_07_brass.h -- bank account classes
    #ifndef CH13_07_BRASS_H_
    #define CH13_07_BRASS_H_
    #include <iostream>
    // Brass Account Class
    class Brass
    {
    private:
    	std::string fullName;
    	long acctNum;
    	double balance;
    public:
    	Brass(const std::string& s = "Nullbody", long an = -1,
    		double bal = 0.0);
    	void Deposit(double amt);
    	virtual void Withdraw(double amt);
    	double Balance() const;
    	virtual void ViewAcct() const;
    	virtual ~Brass() {}
    };
    
    // Brass Plus Account Class
    class BrassPlus : public Brass
    {
    private:
    	double maxLoan;
    	double rate;
    	double owesBank;
    public:
    	BrassPlus(const std::string& s = "Nullbody", long an = -1,
    		double bal = 0.0, double ml = 500,
    		double r = 0.11125);
    	BrassPlus(const Brass & ba, double ml = 500,
    		double r = 0.11125);
    	virtual void ViewAcct() const;
    	virtual void Withdraw(double amt);
    	void ResetMax(double m) { maxLoan = m; }
    	void ResetRate(double r) { rate = r; }
    	void ResetOwes() { owesBank = 0; }
    };
    
    #endif
    ```

    * BrassPlus 类在 Brass 类的基础上添加了3个有数据成员和3公有成员函数；
    * Brass 类和 BrassPlus 类都声明了 ViewAcct() 和 Withdraw() 方法, BrassPlus 对象和 Brass 对象的这些方法的行为是不同的；
    * Brass 类在声明 ViewAcct() 和 Withdraw() 时使用了新关键字 **virtual**。这些方法被称为**虚方法(virtualmethod)**；见P493
      * 如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。
      * 如果没有使用关键字 virtual，程序将根据引用类型或指针类型选择方法；
      * 如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法。
      * ![image-20231227180043808](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231227180043808.png)
    * Brass 类还声明了一个虚析构函数，虽然该析构函数不执行任何操作。
      * 基类声明了一个虚析构函数。这样做是为了确保释放派生对象时，按正确的顺序调用析构函数。

  * 📌如果要在**派生类**中重**新定义基类**的方法，通常应**将基类方法声明为虚的**。这样，程序将根据对象类型而不是引用或指针的类型来选择方法版本。为基类声明一个虚析构函数也是一种惯例。

**1、类实现**

* 示例：

  * ```c++
    // ch13_08_brass.cpp -- bank account class methods
    #include <iostream>
    #include "ch13_07_brass.h"
    using std::cout;
    using std::endl;
    using std::string;
    
    // formatting stuff
    typedef std::ios_base::fmtflags format;
    typedef std::streamsize precis;
    format setFormat();
    void restore(format f, precis p);
    
    // Brass methods
    
    Brass::Brass(const string& s, long an, double bal)
    {
    	fullName = s;
    	acctNum = an;
    	balance = bal;
    }
    
    void Brass::Deposit(double amt)
    {
    	if (amt < 0)
    		cout << "Negative deposit not allowed; "
    		<< "deposit is cancelled.\n";
    	else
    		balance += amt;
    }
    
    void Brass::Withdraw(double amt)
    {
    	// set up ###.## format
    	format initialState = setFormat();
    	precis prec = cout.precision(2);
    
    	if (amt < 0)
    		cout << "Withdrawal amount must be positive;"
    		<< "withdrawal canceled.\n";
    	else if (amt <= balance)
    		balance -= amt;
    	else
    		cout << "Withdrawal amount of $" << amt
    			 << " exceeds your balance.\n"
    			 << "Withdrawal canceled.\n";
    	restore(initialState, prec);
    }
    
    double Brass::Balance() const
    {
    	return balance;
    }
    
    void Brass::ViewAcct() const
    {
    	// set up ###.## format
    	format initialState = setFormat();
    	precis prec = cout.precision(2);
    	cout << "Client: " << fullName << endl;
    	cout << "Account Number: " << acctNum << endl;
    	cout << "Balance: $" << balance << endl;
    	restore(initialState, prec);
    }
    
    // BrassPlus Methods
    BrassPlus::BrassPlus(const string& s, long an, double bal,
    	double ml, double r) : Brass(s, an, bal)
    {
    	maxLoan = ml;
    	owesBank = 0.0;
    	rate = r;
    }
    
    BrassPlus::BrassPlus(const Brass& ba, double ml, double r)
    	: Brass(ba)	// use implicit copy constructor
    {
    	maxLoan = ml;
    	owesBank = 0.0;
    	rate = r;
    }
    
    // redefine how ViewAcct() works
    void BrassPlus::ViewAcct() const
    {
    	// set up ###.## format
    	format initialState = setFormat();
    	precis prec = cout.precision(2);
    
    	Brass::ViewAcct();
    	cout << "Maximum loan: $" << maxLoan << endl;
    	cout << "Owed to bank: $" << oweBank << endl;
    	cout.precision(3);
    	cout << "Loan Rate: " << 100 * rate << "&\n";
    	restore(initialState, prec);
    }
    
    // redefine how Withdraw() works
    void BrassPlus::Withdraw(double amt)
    {
    	// set up ###.## format
    	format initialState = setFormat();
    	precis prec = cout.precision(2);
    
    	double bal = Balance();
    	if (amt <= bal)
    		Brass::Withdraw(amt);
    	else if (amt <= bal + maxLoan - owesBank)
    	{
    		double advance = amt - bal;
    		owesBank += advance * (1.0 + rate);
    		cout << "Bank advance: $" << advance << endl;
    		cout << "Finance charge: $" << advance * rate << endl;
    		Deposit(advance);
    		Brass::Withdraw(amt);
    	}
    	else
    		cout << "Credit limit exceeded. Transaction cancelled.\n";
    	restore(initialState, prec);
    }
    
    format setFormat()
    {
    	// set up ###.## format
    	return cout.setf(std::ios_base::fixed,
    		std::ios_base::floatfield);
    }
    
    void restore(format f, precis p)
    {
    	cout.setf(f, std::ios_base::floatfield);
    	cout.precision(p);
    }
    ```

    * 派生类并不能直接访问基类的私有数据，而必须使用基类的公有方法才能访问这些数据。
      * 派生类构造函数在初始化基类私有数据时，采用的是**成员初始化列表**语法。RatedPlayer 类构造函数和BrassPlus构造函数都使用这种技术。P496
        * 将基类信息传递给基类构造函数，然后使用构造函数体初始化BrassPlus类新增的数据项。
      * 非构造函数不能使用成员初始化列表语法，但派生类方法可以调用公有的基类方法。P496
        * 在派生类方法中，标准技术是使用作用域解析运算符来调用基类方法。
        * 如果派生类没有重新定义该方法，代码不必对函数使用作用域解析运算符。
      * 方法 ViewAcct() 和 Withdraw() 使用格式化方法 setf() 和 precision() 将点值的输出模式设置为定点，即包含两位小数。设置模式后，输出的模式将保持不变，因此该方法将格式模式重置为调用前的状态。
      * 函数 setFormat() 设置定点表示法并返回以前的标记设置；
      * 而函数restore()重置格式和精度。

**2、使用 Brass 和 BrassPlus 类**

* 示例：

  * ```c++
    // ch13_09_usebrass1.cpp -- testing bank account classes
    // compile with ch13_09_usebrass1.cpp
    #include <iostream>
    #include "ch13_07_brass.h"
    
    int main()
    {
    	using std::cout;
    	using std::endl;
    
    	Brass Piggy("Porcelot Pigg", 381299, 4000.00);
    	BrassPlus Hoggy("Horatia Hogg", 382288, 3000.00);
    	Piggy.ViewAcct();
    	cout << endl;
    	Hoggy.ViewAcct();
    	cout << endl;
    	cout << "Depositing $1000 into the Hogg Account:\n";
    	Hoggy.Deposit(1000.00);
    	cout << "New balance: $" << Hoggy.Balance() << endl;
    	cout << "Withdrawing $4200 from the Pigg Account:\n";
    	Piggy.Withdraw(4200.00);
    	cout << "Pigg account balance: $" << Piggy.Balance() << endl;
    	cout << "Withdrawing $4200 from the Hogg Account:\n";
    	Hoggy.Withdraw(4200.00);
    	Hoggy.ViewAcct();
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    Client: Porcelot Pigg
    Account Number: 381299
    Balance: $4000.00
    
    Client: Horatia Hogg
    Account Number: 382288
    Balance: $3000.00
    Maximum loan: $500.00
    Owed to bank: $0.00
    Loan Rate: 11.125%
    
    Depositing $1000 into the Hogg Account:
    New balance: $4000
    Withdrawing $4200 from the Pigg Account:
    Withdrawal amount of $4200.00 exceeds your balance.
    Withdrawal canceled.
    Pigg account balance: $4000
    Withdrawing $4200 from the Hogg Account:
    Bank advance: $200.00
    Finance charge: $22.25
    Client: Horatia Hogg
    Account Number: 382288
    Balance: $0.00
    Maximum loan: $500.00
    Owed to bank: $222.25
    Loan Rate: 11.125%
    ```

**3、演示虚方法的行为**

ch13_09_usebrass1.cpp程序清单中，方法是通过对象（而不是指针或引用）调用的，没有使用虚方法特性，下面来使用虚方法：

* 创建指向Brass的指针数组，每个元素的类型都相同，但由于使用的是公有继承模型，因此Brass指针既可以指向Brass对象也可以指向BrassPlus对象。

* 因此，可以使用一个数组来表示多种类型的对象，这就是多态性。

* 示例：

  * ```c++
    // ch13_10_usebrass2.cpp -- polymorphic example
    // compile with ch13_08_brass.cpp
    #include <iostream>
    #include <string>
    #include "ch13_07_brass.h"
    
    const int CLIENTS = 4;
    
    int main()
    {
    	using std::cin;
    	using std::cout;
    	using std::endl;
    
    	Brass* p_clients[CLIENTS];
    	std::string temp;
    	long tempnum;
    	double tempbal;
    	char kind;
    
    	for (int i = 0; i < CLIENTS; i++)
    	{
    		cout << "Enter client's name: ";
    		getline(cin, temp);
    		cout << "Enter client's account number: ";
    		cin >> tempnum;
    		cout << "Enter opening balance: $";
    		cin >> tempbal;
    		cout << "Enter 1 for Brass Account or "
    			<< "2 for BrassPlus Account: ";
    		while (cin >> kind && (kind != '1' && kind != '2'))
    			cout << "Enter either 1 or 2: ";
    		if (kind == '1')
    			p_clients[i] = new Brass(temp, tempnum, tempbal);
    		else
    		{
    			double tmax, trate;
    			cout << "Enter the overdraft limit: $";
    			cin >> tmax;
    			cout << "Enter the interest rate "
    				<< "as a decimal fraction: ";
    			cin >> trate;
    			p_clients[i] = new BrassPlus(temp, tempnum, tempbal,
    										 tmax, trate);
    		}
    		while (cin.get() != '\n')
    			continue;
    	}
    	cout << endl;
    	for (int i = 0; i < CLIENTS; i++)
    	{
    		p_clients[i]->ViewAcct();
    		// 如果数组成员指向的是 Brass 对象，则调用 Brass::ViewAcct();
    		// 如果数组成员指向的是 BrassPlus 对象，则调用 BrassPlus::ViewAcct();
    		// 如果 Brass::ViewAcct() 被声明为虚的，则在任何情况下都将调用 Brass::ViewAcct()。
    		cout << endl;
    	}
    
    	for (int i = 0; i < CLIENTS; i++)
    	{
    		delete p_clients[i];
    	}
    	cout << "Done.\n";
    	return 0;
    }
    ```

    * ![image-20231228160440479](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231228160440479.png)
      * 报错原因：两个for循环嵌套在了第一个for循环中，程序崩溃。

* 结果：

  * ```c++
    Enter client's name: Harry Fishsong
    Enter client's account number: 112233
    Enter opening balance: $1500
    Enter 1 for Brass Account or 2 for BrassPlus Account: 1
    Enter client's name: Dinah Otternoe
    Enter client's account number: 121213
    Enter opening balance: $1800
    Enter 1 for Brass Account or 2 for BrassPlus Account: 2
    Enter the overdraft limit: $350
    Enter the interest rate as a decimal fraction: 0.12
    Enter client's name: Brenda Birdherd
    Enter client's account number: 212118
    Enter opening balance: $5200
    Enter 1 for Brass Account or 2 for BrassPlus Account: 2
    Enter the overdraft limit: $800
    Enter the interest rate as a decimal fraction: 0.10
    Enter client's name: Tim Turtletop
    Enter client's account number: 233255
    Enter opening balance: $688
    Enter 1 for Brass Account or 2 for BrassPlus Account: 1
    
    Client: Harry Fishsong
    Account Number: 112233
    Balance: $1500.00
    
    Client: Dinah Otternoe
    Account Number: 121213
    Balance: $1800.00
    Maximum loan: $350.00
    Owed to bank: $0.00
    Loan Rate: 12.000%
    
    Client: Brenda Birdherd
    Account Number: 212118
    Balance: $5200.00
    Maximum loan: $800.00
    Owed to bank: $0.00
    Loan Rate: 10.000%
    
    Client: Tim Turtletop
    Account Number: 233255
    Balance: $688.00
    
    Done.
    ```



**4、为何需要析构函数**

在上述程序清单中，使用 delete 释放由 new 分配的对象代码说明了为何基类应包含一个虚析构函数：

* 如果析构函数不是虚的，则将只调用对应于指针类型的析构函数。对于程序清单13.10这意味着只有 Brass 的析构函数被调用，即使指针指的是一个 BrassPlus对象。
* 如果析构数是虚的，将调用相应对象类型的析构函数。
* 因此，如果指针指的是 BrassPlus 对象，将调用 BrassPlus 的析构函数，然后自动调用基类的析构函数。

因此，使用虚析构函数可以确保正确的析构函数序列被调用。

对于程序清单 13.10，这种正确的行为并不是很重要，因为析构函数没有执行任何操作。然而，如果 BrassPlus 包含一个执行某些操作的析构函数，则 Brass 必须有一个虚析构函数，即使该析构函数不执行任何操作。



### 13.4 静态联编和动态联编



