## 第十三章 类继承

面向对象编程的主要目的之一是提供可重用的代码。开发新项目，尤其是当项目十分庞大时，重用经过测试的代码比重新编写代码要好得多。使用已有的代码可以节省时间，由于已有的代码已被使用和测试过，因此有助于避免在程序中引入错误。另外，必须考虑的细节越少，便越能专注于程序的整体策略。

C++提供了比修改代码更好的方法来扩展和修改类。这种方法叫作类继承，它能够从已有的类派生出新的类，而派生类继承了原有类（称为基类）的特征，包括方法。

* 可以在已有类的基础上添加功能。例如，对于数组类，可以添加数学运算。
* 可以给类添加数据。例如，对于字符串类，可以派生出一个类，并添加指定字符串显示颜色的数据成员。
* 可以修改类方法的行为。例如，对于代表提供给飞机乘客的服务的 Passenger 类可以派生出提供更高级别服务的FirstClassPassenger 类。

当然，可以通过复制原始类代码，并对其进行修改来完成上述工作，但继承机制只需提供新特性，甚至不需要访问源代码就可以派生出类。

### 13.1 一个简单的基类

从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。

* 1、基类：

  * 以Webtown俱乐部决定跟踪乒乓球会会员为例，设计一个简单的 TableTennisPlayer 类。

  * TableTennisPlayer 类只是记录会员的姓名以及是否有球桌。

    * ```c++
      #pragma once
      // ch13_01_tabtenn0.h -- a table-tennis base class
      #ifndef CH13_01_TABTENN0_H_
      #define CH13_01_TABTENN0_H_
      #include <string>
      
      using std::string;
      // simple base class
      class TableTennisPlayer
      {
      private:
      	string firstname;
      	string lastname;
      	bool hasTable;
      public:
      	TableTennisPlayer(const string& fn = "none", const string& ln = "none", bool ht = false);
      	void Name() const;
      	bool HasTable() const { return hasTable; };
      	void ResetTable(bool v) { hasTable = v; };
      };
      #endif
      ```

    * ```c++
      // ch13_02_tabtenn0.cpp -- simple base-class method
      #include "ch13_01_tabtenn0.h"
      #include <iostream>
      
      TableTennisPlayer::TableTennisPlayer(const string & fn, 
      	const string & ln, bool ht) : firstname(fn), 
      	lastname(ln), hasTable(ht) {}
      
      void TableTennisPlayer::Name() const
      {
      	std::cout << lastname << ", " << firstname;
      }
      ```

      * 其中ch13_02_tabtenn0.cpp使用了第12章介绍的成员初始化列表语法，等价于下面内容：

        * ```c++
          TableTennisPlayer::TableTennisPlayer(const string & fn, 
          	const string & ln, bool ht)
          {
          	firstname = fn; 
          	lastname = ln;
              hasTable = ht;
          }
          ```

        * 详细步骤是：

          * 这将首先为 firstname 调用 string 的默认构造函数，再调用 string 的赋值运算符将 firstname 设置为 fn，
          * 但初始化列表语法可减少一个步骤，它直接使用 string 的复制构造函数将 firstname 初始化为 fn

    * ```c++
      // ch13_03_usett0.cpp -- using a base class
      #include <iostream>
      #include "ch13_01_tabtenn0.h"
      
      int main(void)
      {
      	using std::cout;
      	TableTennisPlayer player1("Chuck", "Blizzard", true);
      	TableTennisPlayer player2("Tara", "Boomdea", false);
      
      	player1.Name();
      	if (player1.HasTable())
      		cout << ": has a table.\n";
      	else
      		cout << ": hasn't a table.\n";
      
      	player2.Name();
      	if (player2.HasTable())
      		cout << ": has a table.\n";
      	else
      		cout << ": hasn't a table.\n";
      
      	return 0;
      }
      ```

  * 结果：

    * ```c++
      Blizzard, Chuck: has a table.
      Boomdea, Tara: hasn't a table.
      ```

    * 注意到该程序实例化对象时将 C-风格字符串作为参数：

      * ```c++
        TableTennisPlayer player1("Chuck", "Blizzard", true);
        TableTennisPlayer player2("Tara", "Boomdea", false);
        ```

      * 但构造函数的形参类型被声明为 const string &。这导致类型不匹配，但与第12章创建的 String 类一样，string 类有一个将 const char * 作为参数的构造函数，使用C-风格字符串初始化 string 对象时，将自动调用这个构造函数。

      * 总之，**可将 string 对象或C-风格字符串作为构造函数 TableTennisPlayer 的参数**：

        * 将前者作为参数时，将调用接受 const string & 作为参数的 string 构造函数；
        * 而将后者作为参数时，将调用接受 const char* 作为参数的 string 构造函数。
