## 第十三章 类继承

面向对象编程的主要目的之一是提供可重用的代码。开发新项目，尤其是当项目十分庞大时，重用经过测试的代码比重新编写代码要好得多。使用已有的代码可以节省时间，由于已有的代码已被使用和测试过，因此有助于避免在程序中引入错误。另外，必须考虑的细节越少，便越能专注于程序的整体策略。

C++提供了比修改代码更好的方法来扩展和修改类。这种方法叫作类继承，它能够从已有的类派生出新的类，而派生类继承了原有类（称为基类）的特征，包括方法。

* 可以在已有类的基础上添加功能。例如，对于数组类，可以添加数学运算。
* 可以给类添加数据。例如，对于字符串类，可以派生出一个类，并添加指定字符串显示颜色的数据成员。
* 可以修改类方法的行为。例如，对于代表提供给飞机乘客的服务的 Passenger 类可以派生出提供更高级别服务的FirstClassPassenger 类。

当然，可以通过复制原始类代码，并对其进行修改来完成上述工作，但继承机制只需提供新特性，甚至不需要访问源代码就可以派生出类。

### 13.1 一个简单的基类

从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。

* 1、基类：

  * 以Webtown俱乐部决定跟踪乒乓球会会员为例，设计一个简单的 TableTennisPlayer 类。

  * TableTennisPlayer 类只是记录会员的姓名以及是否有球桌。

    * ```c++
      #pragma once
      // ch13_01_tabtenn0.h -- a table-tennis base class
      #ifndef CH13_01_TABTENN0_H_
      #define CH13_01_TABTENN0_H_
      #include <string>
      
      using std::string;
      // simple base class
      class TableTennisPlayer
      {
      private:
      	string firstname;
      	string lastname;
      	bool hasTable;
      public:
      	TableTennisPlayer(const string& fn = "none", const string& ln = "none", bool ht = false);
      	void Name() const;
      	bool HasTable() const { return hasTable; };
      	void ResetTable(bool v) { hasTable = v; };
      };
      #endif
      ```

    * ```c++
      // ch13_02_tabtenn0.cpp -- simple base-class method
      #include "ch13_01_tabtenn0.h"
      #include <iostream>
      
      TableTennisPlayer::TableTennisPlayer(const string & fn, 
      	const string & ln, bool ht) : firstname(fn), 
      	lastname(ln), hasTable(ht) {}
      
      void TableTennisPlayer::Name() const
      {
      	std::cout << lastname << ", " << firstname;
      }
      ```

      * 其中ch13_02_tabtenn0.cpp使用了第12章介绍的成员初始化列表语法，等价于下面内容：

        * ```c++
          TableTennisPlayer::TableTennisPlayer(const string & fn, 
          	const string & ln, bool ht)
          {
          	firstname = fn; 
          	lastname = ln;
              hasTable = ht;
          }
          ```

        * 详细步骤是：

          * 这将首先为 firstname 调用 string 的默认构造函数，再调用 string 的赋值运算符将 firstname 设置为 fn，
          * 但初始化列表语法可减少一个步骤，它直接使用 string 的复制构造函数将 firstname 初始化为 fn

    * ```c++
      // ch13_03_usett0.cpp -- using a base class
      #include <iostream>
      #include "ch13_01_tabtenn0.h"
      
      int main(void)
      {
      	using std::cout;
      	TableTennisPlayer player1("Chuck", "Blizzard", true);
      	TableTennisPlayer player2("Tara", "Boomdea", false);
      
      	player1.Name();
      	if (player1.HasTable())
      		cout << ": has a table.\n";
      	else
      		cout << ": hasn't a table.\n";
      
      	player2.Name();
      	if (player2.HasTable())
      		cout << ": has a table.\n";
      	else
      		cout << ": hasn't a table.\n";
      
      	return 0;
      }
      ```

  * 结果：

    * ```c++
      Blizzard, Chuck: has a table.
      Boomdea, Tara: hasn't a table.
      ```

    * 注意到该程序实例化对象时将 C-风格字符串作为参数：

      * ```c++
        TableTennisPlayer player1("Chuck", "Blizzard", true);
        TableTennisPlayer player2("Tara", "Boomdea", false);
        ```

      * 但构造函数的形参类型被声明为 const string &。这导致类型不匹配，但与第12章创建的 String 类一样，string 类有一个将 const char * 作为参数的构造函数，使用C-风格字符串初始化 string 对象时，将自动调用这个构造函数。

      * 总之，**可将 string 对象或C-风格字符串作为构造函数 TableTennisPlayer 的参数**：

        * 将前者作为参数时，将调用接受 const string & 作为参数的 string 构造函数；
        * 而将后者作为参数时，将调用接受 const char* 作为参数的 string 构造函数。

#### 13.1.1 派生一个类

Webtown 俱乐部的一些成员**曾经**参加过当地的乒乓球锦标赛：需要这样一个类，它能包括成员在比赛中的比分。

* 与其从零开始，不如从 TableTennisClass 类派生出一个类。首先将 RatedPlayer 类声明为从 TableTennisClass 类派生而来：

  * ```c++
    // RatedPlayer derives from the TableTennisPlayer base class
    class RatedPlayer : public TableTennisPlayer
    {
    ...
    };
    ```

  * 冒号指出 RatedPlayer 类的基类是 public TableTennisPlayer 类。

  * “class RatedPlayer : public TableTennisPlayer”特殊的声明头表明 TableTennisPlayer 是一个公有基类，这被称为公有派生。

    * 派生类对象包含基类对象；
    * 使用公有派生：
      * 基类的公有成员将成为派生类的共有成员；
      * 基类的私有部分称为派生类的一部分，但只能通过基类的公有和保护方法访问。

  * RatedPlayer 对象将具有以下特征：

    * 派生类对象储存了基类的数据成员（派生类继承了基类的实现）；
    * 派生类对象可以使用基类的方法（派生类继承了基类的接口）。
    * 因此，RatedPlayer 对象可以储存运动员的姓名及其是否有球桌，另外还可以使用 T 类的Name()、hasTable()、ResetTable()方法：
      * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/3dc3f49a-a1a3-490d-9ed5-5ecbb3b498fe)

  * 需要再继承特性中添加什么呢：

    * 派生类需要自己的构造函数。

    * 派生类可以根据需要添加额外的数据成员和成员函数。

    * 在这个例子中，派生类需要另一个数据成员来存储比分，还应包含检索比分的方法和重置比分的方法。因此，类声明与下面类似：

      * ```c++
        // simple detived class
        class RatedPlayer : public TableTennisPlayer
        {
        private:
            unsigned int rating;	// add a data member
        public:
            RatedPlayer (unsigned int r = 0, const string & fn = "none", const string& ln = "none", bool ht = false);
            RatedPlayer (unsigned int r, const TableTennisPlayer & tp);
            unsigned int Rating () const { return rating; }		// add a method
            void ResetRating (unsigned int r) { rating = r; }	// add a method
        };
        ```

#### 13.1.2 构造函数：访问权限的考虑

📌派生类不能直接访问基类的私有成员，而必须通过基类方进行访问。具体地说，派生类构造函数必须使用基类构造函数。

创建派生对象时，程序首先创建基类对象：

* ```c++
  RatedPlayer::RatedPlayer(unsigned int r, const string & fn,
                          const string & ln, bool ht) : TableTennisPlayer(fn, 
                          ln, ht)
  {
      rating = r;
  }
  ```

* 其中：**TableTennisPlayer (fn, ln, ht) 是成员初始化列表**。它是可执行的代码，调用TableTennisPlayer构造函数：

  * ```C++
    RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
    ```

    * RatedPlayer构造函数将把实参（"Mallory", "Duck", true）赋给形参（fn, ln, ht）
    * 然后将这些参数作为实参传递给TableTennisPlayer构造函数，该函数将创建一个嵌套TableTennisPlayer对象，并将数据（"Mallory", "Duck", true）存储在该对象中。
    * 最后，程序进入RatedPlayer构造函数构造函数体，完成RealPlayer对象的创建，并将参数的 r 值（1140）赋给rating成员：
      * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/24b7d846-aaf7-447f-b044-20ad6e2dc6c2)


  * 如果省略成员初始化列表，程序会使用默认的基类构造函数进行创建基类对象，见P485

* 如果愿意，也可以对派生类成员使用成员初始化列表语法。在这种情况下，应在列表中使用**成员名**，而不是类名。所以，第二个构造函数可以按照下述方式编写：

  * ```c++
    // alternative version
    RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer & tp)
        : TableTennisPlayer(tp), rating(r)
        {
        }
    ```

* 有关派生类构造函数的要点如下：

  * 首先创建基类对象；
  * 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；
  * 派生类构造函数应初始化派生类新增的数据成员。

* 创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数：

  * 基类构造函数负责初始化继承的数据成员；
  * 派生类构造函数主要用于初始化新增的数据成员。
    * 派生类的构造函数总是调用一个基类构造函数。可以使用初始化器列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。
    * 派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。

📌成员初始化列表：

* 派生类构造函数可以使用初始化器列表机制将值传递给基类构造函数：

  * ```c++
    derived::derived(type1 x, type2 y) : base(x, y)
    {
        ...
    }
    ```

  * 其中 derived 是派生类，base 是基类，x和y是基类构造函数使用的变量。

  * 如果没有在成员初始化列表中提供基类构造函数，程序将使用默认的基类构造函数。成员初始化列表只能用于构造函数。



#### 13.1.3 使用派生类

要使用派生类，程序必须要**能够访问基类声明**。程序清单 13.4 将这**两种类**的**声明**置于**同一个头文件**中。也可以将每个类放在独立的头文件中，但由于这两个类是相关的，所以把其类声明放在一起更合适。

* 示例：

  * ```c++
    #pragma once
    // ch13_04_tabtenn1.h -- a table-tennis base class
    #ifndef CH13_04_TABTENN1_H_
    #define CH13_04_TABTENN1_H_
    #include<string>
    using std::string;
    // simple base class
    class TableTennisPlayer
    {
    private:
    	string firstname;
    	string lastname;
    	bool hasTable;
    public:
    	TableTennisPlayer(const string& fn = "none",
    					  const string& ln = "none", bool ht = false);
    	void Name() const;
    	bool HasTable() const { return hasTable; };
    	void ResetTable(bool v) { hasTable = v; };
    };
    
    // simple derived class
    class RatedPlayer : public TableTennisPlayer
    {
    private:
    	unsigned int rating;
    public:
    	RatedPlayer(unsigned int r = 0, const string& fn = "none",
    				const string& ln = "none", bool ht = false);
    	RatedPlayer(unsigned int r, const TableTennisPlayer& tp);
    	unsigned int Rating() const { return rating; }
    	void ResetRating(unsigned int r) { rating = r; }
    };
    #endif
    ```

  * ```c++
    // ch13_05_tabtenn1.cpp -- simple base-class methods
    #include "ch13_04_tabtenn1.h"
    #include <iostream>
    
    TableTennisPlayer::TableTennisPlayer (const string & fn,
    	const string & ln, bool ht) : firstname(fn),
    	lastname(ln), hasTable(ht) {}
    
    void TableTennisPlayer::Name() const
    {
    	std::cout << lastname << ", " << firstname;
    }
    
    // RatedPlayer methods
    RatedPlayer::RatedPlayer (unsigned int r, const string& fn,
    	const string& ln, bool ht) : TableTennisPlayer(fn, ln, ht)
    {
    	rating = r;
    }
    
    RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer& tp)
    	: TableTennisPlayer(tp), rating(r)
    {
    }
    ```

  * ```c++
    // ch13_06_usett1.cpp -- using base class and derived class
    #include <iostream>
    #include "ch13_04_tabtenn1.h"
    
    int main(void)
    {
    	using std::cout;
    	using std::endl;
    	TableTennisPlayer player1("Tara", "Boomdea", false);
    	RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
    	rplayer1.Name();
    	if (rplayer1.HasTable())
    		cout << ": has a table.\n";
    	else
    		cout << ": hasn't a table.\n";
    	player1.Name();
    	if (player1.HasTable())
    		cout << ": has a table\n";
    	else
    		cout << ": hasn't a table.\n";
    	cout << "Name: ";
    	rplayer1.Name();
    	cout << "; Rating: " << rplayer1.Rating() << endl;
    	RatedPlayer rplayer2(1212, player1);
    	cout << "Name: ";
    	rplayer2.Name();
    	cout << "; Rating: " << rplayer2.Rating() << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    Duck, Mallory: has a table.
    Boomdea, Tara: hasn't a table.
    Name: Duck, Mallory; Rating: 1140
    Name: Boomdea, Tara; Rating: 1212
    ```



#### 13.1.4 派生类和基类之间的特殊关系

（1）派生类对象可以使用基类的方法，条件是方法不是私有的；

* ```c++
  RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
  rplayer1.Name();
  ```

（2）基类指针可以在不进行显式类型转换的情况下指向派生类对象；

* ```c++
  RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
  TableTennisPlayer * pt = &rplayer;
  py->Name();
  ```

（3）基类应用可以在不进行显式类型转换的情况下引用派生类对象/

* ```c++
  RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
  TableTennisPlayer & rt = rplayer;
  rt.Name();
  ```

❗基类**指针**或**引用**只能调用基类方法，因此，不能使用rt或pt来调用派生类的ResetRanking方法。

❗可以将派生类对象和地址赋给基类应用和指针。（包含关系）

* 通常，C++要求引用和指针类型与赋给的类型匹配，但这一规则对**继承**来说是例外。然而，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针。
* 代码见P488，这一部分很深奥，在后续应用过程中可以反复翻阅查看



### 13.2 继承：is-a关系
