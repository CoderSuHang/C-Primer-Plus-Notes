## 第八章 函数探幽

### 8.1 C++内联函数

* 相当于对调用函数进行复制，在使用的地方添加副本：

  * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/86ae4cb5-f516-4bd8-a87f-f443b4a67590)


* 使用内联函数的措施：

  * 在函数声明前加上关键字inline；
  * 在函数定义前加上关键字inline；

* 通常做法：

  * 省略函数原型（main函数之前的内容），将整个定义（即函数有和所有函数代码）放在本应提供原型的地方。
  * 内联函数不能递归；

* 示例：

  * ```c++
    // ch08_01_inline.cpp -- using an inline function
    #include <iostream>
    inline double square(double x) { return x * x; }
    
    int main() {
    	using namespace std;
    	double a, b;
    	double c = 13.0;
    
    	a = square(5.0);
    	b = square(4.5 + 7.5);
    
    	cout << "a = " << a << ", b = " << b << endl;
    	cout << "c = " << c;
    	cout << ", c squared = " << square(c++) << endl;
    	cout << "Now c = " << c << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    a = 25, b = 144
    c = 13, c squared = 169
    Now c = 14
    ```

  * P255页介绍了内联与宏，这里不多展开，如果使用C语言的宏执行了类似函数的功能，应考虑将它们转换为C++内联函数。



### 8.2 引用变量

* 一下内容旨在说明引用时如何工作的，而不是其典型用法。

#### 8.2.1 创建引用变量

* & 的另一种含义：将其用来声明引用：

  * ```c++
    int rats;
    int & rodents = rats;
    ```

  * int * 指的是指向 int 的引用。

  * 上述声明将允许 rats 和 rodents 互换——它们指向相同的内存单元。

* 示例：

  * ```c++
    // ch08_02_firstref.cpp -- defning and using a reference
    #include <iostream>
    int main() {
    	using namespace std;
    	int rats = 101;
    	int& rodents = rats;
    
    	cout << "rats = " << rats;
    	cout << ", rodents = " << rodents << endl;
    
    	rodents++;
    	cout << "rats = " << rats;
    	cout << ", rodents = " << rodents << endl;
    
    	cout << "rats address = " << &rats;
    	cout << ", rodents address = " << &rodents << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    rats = 101, rodents = 101
    rats = 102, rodents = 102
    rats address = 0056FBB8, rodents address = 0056FBB8
    ```

* 引用看上去很像伪装表示的指针，但不同于指针：

  * 必须在声明引用时将其初始化，而不能像声明指针那样，先声明再赋值：

    * ```c++
      int rat;
      int & rodent;
      rodent = rat;//No, you can't do this.
      ```

  * 引用更接近 const 指针，必须在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它：

    * ```c++
      int & rodents = rats;
      ```

    * 实际上就是：

    * ```c++
      int * const pr = &rats;
      ```

    * 其中引用rodents扮演的角色与表达式*pr相同。

  * 示例：

    * ```c++
      // ch08_03_sceref.cpp -- defining and using a reference
      #include <iostream>
      
      int main() {
      	using namespace std;
      	int rats = 101;
      	int& rodents = rats;
      
      	cout << "rats = " << rats;
      	cout << ", rodents = " << rodents << endl;
      
      	cout << "rats address = " << &rats;
      	cout << ", rodents address = " << &rodents << endl;
      
      	int bunnies = 50;
      	rodents = bunnies;
      
      	cout << "bunnies = " << bunnies;
      	cout << ", rats = " << rats;
      	cout << ", rodents = " << rodents << endl;
      
      	cout << "bunnies address = " << &bunnies;
      	cout << ", rodents address = " << &rodents << endl;
      
      	return 0;
      }
      ```

  * 结果：

    * ```c++
      rats = 101, rodents = 101
      rats address = 007EF8E4, rodents address = 007EF8E4
      bunnies = 50, rats = 50, rodents = 50
      bunnies address = 007EF8CC, rodents address = 007EF8E4
      ```



#### 8.2.2 将引用用作函数参数

* 引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。
  * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/62beb06a-932d-42b0-8690-1588bc36aadf)


* 示例：（演示了交换变量函数使用引用、指针的对比）

  * ```c++
    // ch08_04_swaps.cpp -- swapping with references and with pointers
    #include <iostream>
    void swapr(int& a, int& b);
    void swapp(int* p, int* q);
    void swapv(int a, int b);
    
    int main() {
    	using namespace std;
    	int wallet1 = 300;
    	int wallet2 = 350;
    
    	cout << "wallet1 = $" << wallet1;
    	cout << " wallet2 = $" << wallet2 << endl;
    
    	cout << "Using references to swap contents:\n";
    	swapr(wallet1, wallet2);
    	cout << "wallet1 = $" << wallet1;
    	cout << " wallet2 = $" << wallet2 << endl;
    
    	cout << "Using pointers to swap contents again:\n";
    	swapp(&wallet1, &wallet2);
    	cout << "wallet1 = $" << wallet1;
    	cout << " wallet2 = $" << wallet2 << endl;
    
    	cout << "Trying to use passing by value:\n";
    	swapv(wallet1, wallet2);
    	cout << "wallet1 = $" << wallet1;
    	cout << " wallet2 = $" << wallet2 << endl;
    
    	return 0;
    }
    
    void swapr(int& a, int& b) {
    	int temp;
    
    	temp = a;
    	a = b;
    	b = temp;
    }
    
    void swapp(int* p, int* q) {
    	int temp;
    
    	temp = *p;
    	*p = *q;
    	*q = temp;
    }
    
    void swapv(int a, int b) {
    	int temp;
    
    	temp = a;
    	a = b;
    	b = temp;
    }
    ```

* 结果：

  * ```c++
    wallet1 = $300 wallet2 = $350
    Using references to swap contents:
    wallet1 = $350 wallet2 = $300
    Using pointers to swap contents again:
    wallet1 = $300 wallet2 = $350
    Trying to use passing by value:
    wallet1 = $300 wallet2 = $350
    ```

  * 不同介绍在P260



#### 8.2.3 引用的属性和特别之处

* 示例：

  * ```c++
    // ch08_05_cubes.cpp -- regular and reference arguments
    #include <iostream>
    double cube(double a);
    double refcube(double& ra);
    
    int main() {
    	using namespace std;
    	double x = 3.0;
    
    	cout << cube(x);
    	cout << " = cube of " << x << endl;
    
    	cout << refcube(x);
    	cout << " = cube of " << x << endl;
    
    	return 0;
    }
    
    double cube(double a) {
    	a *= a * a;
    	return a;
    }
    
    double refcube(double& ra) {
    	ra *= ra * ra;
    	return ra;
    }
    ```

* 结果：

  * ```c++
    27 = cube of 3
    27 = cube of 27
    ```

  * 值得注意的地方：P261-P262

    * 按值传递的输入参数可以是变量，也可以是表达式；
    * 但是引用作为函数参数时，只能是变量，不可以是表达式。在引用const时，编译器才会在特定情况下创建表达式生成的临时变量，见P262。

  * 应尽可能使用const：

    * 使用 const 可以避免无意中修改数据的编程错误；
    * 使用 const使函数能够处理 const 和非 const 实参，否则将只能接受非 const 数据；
    * 使用 const 引用使函数能够正确生成并使用临时变量。



#### 8.2.4 将引用用于结构
