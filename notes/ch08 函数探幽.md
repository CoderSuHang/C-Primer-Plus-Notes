## 第八章 函数探幽

### 8.1 C++内联函数

* 相当于对调用函数进行复制，在使用的地方添加副本：

  * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/86ae4cb5-f516-4bd8-a87f-f443b4a67590)


* 使用内联函数的措施：

  * 在函数声明前加上关键字inline；
  * 在函数定义前加上关键字inline；

* 通常做法：

  * 省略函数原型（main函数之前的内容），将整个定义（即函数有和所有函数代码）放在本应提供原型的地方。
  * 内联函数不能递归；

* 示例：

  * ```c++
    // ch08_01_inline.cpp -- using an inline function
    #include <iostream>
    inline double square(double x) { return x * x; }
    
    int main() {
    	using namespace std;
    	double a, b;
    	double c = 13.0;
    
    	a = square(5.0);
    	b = square(4.5 + 7.5);
    
    	cout << "a = " << a << ", b = " << b << endl;
    	cout << "c = " << c;
    	cout << ", c squared = " << square(c++) << endl;
    	cout << "Now c = " << c << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    a = 25, b = 144
    c = 13, c squared = 169
    Now c = 14
    ```

  * P255页介绍了内联与宏，这里不多展开，如果使用C语言的宏执行了类似函数的功能，应考虑将它们转换为C++内联函数。



### 8.2 引用变量

* 一下内容旨在说明引用时如何工作的，而不是其典型用法。

#### 8.2.1 创建引用变量

* & 的另一种含义：将其用来声明引用：

  * ```c++
    int rats;
    int & rodents = rats;
    ```

  * int * 指的是指向 int 的引用。

  * 上述声明将允许 rats 和 rodents 互换——它们指向相同的内存单元。

* 示例：

  * ```c++
    // ch08_02_firstref.cpp -- defning and using a reference
    #include <iostream>
    int main() {
    	using namespace std;
    	int rats = 101;
    	int& rodents = rats;
    
    	cout << "rats = " << rats;
    	cout << ", rodents = " << rodents << endl;
    
    	rodents++;
    	cout << "rats = " << rats;
    	cout << ", rodents = " << rodents << endl;
    
    	cout << "rats address = " << &rats;
    	cout << ", rodents address = " << &rodents << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    rats = 101, rodents = 101
    rats = 102, rodents = 102
    rats address = 0056FBB8, rodents address = 0056FBB8
    ```

* 引用看上去很像伪装表示的指针，但不同于指针：

  * 必须在声明引用时将其初始化，而不能像声明指针那样，先声明再赋值：

    * ```c++
      int rat;
      int & rodent;
      rodent = rat;//No, you can't do this.
      ```

  * 引用更接近 const 指针，必须在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它：

    * ```c++
      int & rodents = rats;
      ```

    * 实际上就是：

    * ```c++
      int * const pr = &rats;
      ```

    * 其中引用rodents扮演的角色与表达式*pr相同。

  * 示例：

    * ```c++
      // ch08_03_sceref.cpp -- defining and using a reference
      #include <iostream>
      
      int main() {
      	using namespace std;
      	int rats = 101;
      	int& rodents = rats;
      
      	cout << "rats = " << rats;
      	cout << ", rodents = " << rodents << endl;
      
      	cout << "rats address = " << &rats;
      	cout << ", rodents address = " << &rodents << endl;
      
      	int bunnies = 50;
      	rodents = bunnies;
      
      	cout << "bunnies = " << bunnies;
      	cout << ", rats = " << rats;
      	cout << ", rodents = " << rodents << endl;
      
      	cout << "bunnies address = " << &bunnies;
      	cout << ", rodents address = " << &rodents << endl;
      
      	return 0;
      }
      ```

  * 结果：

    * ```c++
      rats = 101, rodents = 101
      rats address = 007EF8E4, rodents address = 007EF8E4
      bunnies = 50, rats = 50, rodents = 50
      bunnies address = 007EF8CC, rodents address = 007EF8E4
      ```



#### 8.2.2 将引用用作函数参数

* 引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。
  * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/62beb06a-932d-42b0-8690-1588bc36aadf)


* 示例：（演示了交换变量函数使用引用、指针的对比）
