## 第八章 函数探幽

### 8.1 C++内联函数

* 相当于对调用函数进行复制，在使用的地方添加副本：

  * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/86ae4cb5-f516-4bd8-a87f-f443b4a67590)


* 使用内联函数的措施：

  * 在函数声明前加上关键字inline；
  * 在函数定义前加上关键字inline；

* 通常做法：

  * 省略函数原型（main函数之前的内容），将整个定义（即函数有和所有函数代码）放在本应提供原型的地方。
  * 内联函数不能递归；

* 示例：

  * ```c++
    // ch08_01_inline.cpp -- using an inline function
    #include <iostream>
    inline double square(double x) { return x * x; }
    
    int main() {
    	using namespace std;
    	double a, b;
    	double c = 13.0;
    
    	a = square(5.0);
    	b = square(4.5 + 7.5);
    
    	cout << "a = " << a << ", b = " << b << endl;
    	cout << "c = " << c;
    	cout << ", c squared = " << square(c++) << endl;
    	cout << "Now c = " << c << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    a = 25, b = 144
    c = 13, c squared = 169
    Now c = 14
    ```

  * P255页介绍了内联与宏，这里不多展开，如果使用C语言的宏执行了类似函数的功能，应考虑将它们转换为C++内联函数。



### 8.2 引用变量

* 一下内容旨在说明引用时如何工作的，而不是其典型用法。

#### 8.2.1 创建引用变量

* & 的另一种含义：将其用来声明引用：

  * ```c++
    int rats;
    int & rodents = rats;
    ```

  * int * 指的是指向 int 的引用。

  * 上述声明将允许 rats 和 rodents 互换——它们指向相同的内存单元。

* 示例：

  * ```c++
    // ch08_02_firstref.cpp -- defning and using a reference
    #include <iostream>
    int main() {
    	using namespace std;
    	int rats = 101;
    	int& rodents = rats;
    
    	cout << "rats = " << rats;
    	cout << ", rodents = " << rodents << endl;
    
    	rodents++;
    	cout << "rats = " << rats;
    	cout << ", rodents = " << rodents << endl;
    
    	cout << "rats address = " << &rats;
    	cout << ", rodents address = " << &rodents << endl;
    
    	return 0;
    }
    ```

* 结果：

  * ```c++
    rats = 101, rodents = 101
    rats = 102, rodents = 102
    rats address = 0056FBB8, rodents address = 0056FBB8
    ```

* 引用看上去很像伪装表示的指针，但不同于指针：

  * 必须在声明引用时将其初始化，而不能像声明指针那样，先声明再赋值：

    * ```c++
      int rat;
      int & rodent;
      rodent = rat;//No, you can't do this.
      ```

  * 引用更接近 const 指针，必须在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它：

    * ```c++
      int & rodents = rats;
      ```

    * 实际上就是：

    * ```c++
      int * const pr = &rats;
      ```

    * 其中引用rodents扮演的角色与表达式*pr相同。

  * 示例：

    * ```c++
      // ch08_03_sceref.cpp -- defining and using a reference
      #include <iostream>
      
      int main() {
      	using namespace std;
      	int rats = 101;
      	int& rodents = rats;
      
      	cout << "rats = " << rats;
      	cout << ", rodents = " << rodents << endl;
      
      	cout << "rats address = " << &rats;
      	cout << ", rodents address = " << &rodents << endl;
      
      	int bunnies = 50;
      	rodents = bunnies;
      
      	cout << "bunnies = " << bunnies;
      	cout << ", rats = " << rats;
      	cout << ", rodents = " << rodents << endl;
      
      	cout << "bunnies address = " << &bunnies;
      	cout << ", rodents address = " << &rodents << endl;
      
      	return 0;
      }
      ```

  * 结果：

    * ```c++
      rats = 101, rodents = 101
      rats address = 007EF8E4, rodents address = 007EF8E4
      bunnies = 50, rats = 50, rodents = 50
      bunnies address = 007EF8CC, rodents address = 007EF8E4
      ```



#### 8.2.2 将引用用作函数参数

* 引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。
  * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/62beb06a-932d-42b0-8690-1588bc36aadf)


* 示例：（演示了交换变量函数使用引用、指针的对比）

  * ```c++
    // ch08_04_swaps.cpp -- swapping with references and with pointers
    #include <iostream>
    void swapr(int& a, int& b);
    void swapp(int* p, int* q);
    void swapv(int a, int b);
    
    int main() {
    	using namespace std;
    	int wallet1 = 300;
    	int wallet2 = 350;
    
    	cout << "wallet1 = $" << wallet1;
    	cout << " wallet2 = $" << wallet2 << endl;
    
    	cout << "Using references to swap contents:\n";
    	swapr(wallet1, wallet2);
    	cout << "wallet1 = $" << wallet1;
    	cout << " wallet2 = $" << wallet2 << endl;
    
    	cout << "Using pointers to swap contents again:\n";
    	swapp(&wallet1, &wallet2);
    	cout << "wallet1 = $" << wallet1;
    	cout << " wallet2 = $" << wallet2 << endl;
    
    	cout << "Trying to use passing by value:\n";
    	swapv(wallet1, wallet2);
    	cout << "wallet1 = $" << wallet1;
    	cout << " wallet2 = $" << wallet2 << endl;
    
    	return 0;
    }
    
    void swapr(int& a, int& b) {
    	int temp;
    
    	temp = a;
    	a = b;
    	b = temp;
    }
    
    void swapp(int* p, int* q) {
    	int temp;
    
    	temp = *p;
    	*p = *q;
    	*q = temp;
    }
    
    void swapv(int a, int b) {
    	int temp;
    
    	temp = a;
    	a = b;
    	b = temp;
    }
    ```

* 结果：

  * ```c++
    wallet1 = $300 wallet2 = $350
    Using references to swap contents:
    wallet1 = $350 wallet2 = $300
    Using pointers to swap contents again:
    wallet1 = $300 wallet2 = $350
    Trying to use passing by value:
    wallet1 = $300 wallet2 = $350
    ```

  * 不同介绍在P260



#### 8.2.3 引用的属性和特别之处

* 示例：

  * ```c++
    // ch08_05_cubes.cpp -- regular and reference arguments
    #include <iostream>
    double cube(double a);
    double refcube(double& ra);
    
    int main() {
    	using namespace std;
    	double x = 3.0;
    
    	cout << cube(x);
    	cout << " = cube of " << x << endl;
    
    	cout << refcube(x);
    	cout << " = cube of " << x << endl;
    
    	return 0;
    }
    
    double cube(double a) {
    	a *= a * a;
    	return a;
    }
    
    double refcube(double& ra) {
    	ra *= ra * ra;
    	return ra;
    }
    ```

* 结果：

  * ```c++
    27 = cube of 3
    27 = cube of 27
    ```

  * 值得注意的地方：P261-P262

    * 按值传递的输入参数可以是变量，也可以是表达式；
    * 但是引用作为函数参数时，只能是变量，不可以是表达式。在引用const时，编译器才会在特定情况下创建表达式生成的临时变量，见P262。

  * 应尽可能使用const：

    * 使用 const 可以避免无意中修改数据的编程错误；
    * 使用 const使函数能够处理 const 和非 const 实参，否则将只能接受非 const 数据；
    * 使用 const 引用使函数能够正确生成并使用临时变量。



#### 8.2.4 将引用用于结构

* 使用结构引用参数的方式与使用基本变量引用相同，只需在声明结构参数时使用引用运算符&即可：

  * ```c++
    struct free_throws{
        std::string name;
        int made;
        int attempts;
        float percent;
    };
    ```

  * 则可以如下编写函数原型，在函数中将指向该结构的引用作为参数：

    * ```c++
      void set_pc(free_throws & ft);
      ```

  * 如果不希望函数修改传入的结构，可使用const：

    * ```c++
      void display(const free_throws & ft);
      ```

* 示例：

  * ```c++
    // ch08_06_strtref.cpp -- using structure references
    #include <iostream>
    #include <string>
    struct free_throws {
    	std::string name;
    	int made;
    	int attempts;
    	float percent;
    };
    
    void display(const free_throws& ft);
    void set_pc(free_throws& ft);
    free_throws& accumulate(free_throws& target, const free_throws& source);
    
    int main() {
    	free_throws one = { "Ifelsa Branch", 13, 14 };
    	free_throws two = { "Andor Knott", 10, 16 };
    	free_throws three = { "Minnie Max", 7, 9 };
    	free_throws four = {"Whily Looper", 5, 9};
    	free_throws five = {"Long Long", 6, 14};
    	free_throws team = {"Throwgoods", 0, 0};
    	free_throws dup;
    
    	set_pc(one);
    	display(one);
    	accumulate(team, one);
    	display(team);
    	display(accumulate(team, two));
    	accumulate(accumulate(team, three), four);
    	display(team);
    
    	dup = accumulate(team, five);
    	std::cout << "Displaying team:\n";
    	display(team);
    	std::cout << "Displaying dup after assignment:\n";
    	display(dup);
    
    	set_pc(four);
    	accumulate(dup, five) = four;
    	std::cout << "Displaying dup after ill-advised assignment:\n";
    	display(dup);
    
    	return 0;
    }
    
    void display(const free_throws& ft) {
    	using std::cout;
    	cout << "Name: " << ft.name << '\n';
    	cout << " Made: " << ft.made << '\t';
    	cout << "Attempts: " << ft.attempts << '\t';
    	cout << "Percent: " << ft.percent << '\n';
    }
    
    void set_pc(free_throws& ft) {
    	if (ft.attempts != 0)
    		ft.percent = 100.0f * float(ft.made) / float(ft.attempts);
    	else
    		ft.percent = 0;
    }
    
    free_throws& accumulate(free_throws& target, const free_throws& source) {
    	target.attempts += source.attempts;
    	target.made += source.made;
    	set_pc(target);
    	return target;
    }
    ```

* 结果：

  * ```c++
    Name: Ifelsa Branch
     Made: 13       Attempts: 14    Percent: 92.8571
    Name: Throwgoods
     Made: 13       Attempts: 14    Percent: 92.8571
    Name: Throwgoods
     Made: 23       Attempts: 30    Percent: 76.6667
    Name: Throwgoods
     Made: 35       Attempts: 48    Percent: 72.9167
    Displaying team:
    Name: Throwgoods
     Made: 41       Attempts: 62    Percent: 66.129
    Displaying dup after assignment:
    Name: Throwgoods
     Made: 41       Attempts: 62    Percent: 66.129
    Displaying dup after ill-advised assignment:
    Name: Whily Looper
     Made: 5        Attempts: 9     Percent: 55.5556
    ```

  * 如果返回类型被声明为 free throws 而不是free throws &，上述返回语将返回target (也就是team)的拷贝。但返回类型为引用，这意味着返回的是最初传递给accumulate()的team对象：

    * ```c++
      free_throws& accumulate(free_throws& target, const free_throws& source);
      ```

  * 为何要返回引用？

    * P267：如果 accumulate0返回一个结构，而不是指向结构的引用，将把整个结构复制到一个临时位置，再将这个拷贝复制给 dup。但在返回值为引用时，将直接把team 复制到dup，其效率更高。

  * 返回引用时需要注意的问题：

    * 返回引用时最重要的一点是，应避免返回函数终止时不再存在的内存单元引用。（即避免函数返回一个指向临时变量的引用，函数运行完毕后它将不再存在）
    * 改进办法见P268；

  * 如何将const用于引用返回类型？

    * 见P268。



#### 8.2.5 将引用用于类对象

* 示例（使用 string 类）：

  * ```c++
    // ch08_07_strquote.cpp -- different designs
    #include <iostream>
    #include <string>
    
    using namespace std;
    string version1(const string& s1, const string& s2);
    const string& version2(string& s1, const string& s2);
    const string& version3(string& s1, const string& s2);
    
    int main() {
    	string input;
    	string copy;
    	string result;
    
    	cout << "Enter a string: ";
    	getline(cin, input);
    	copy = input;
    	cout << "Your string as entered: " << input << endl;
    	result = version1(input, "***");
    	cout << "Your string enhanced: " << result << endl;
    	cout << "Your original string: " << input << endl;
    
    	result = version2(input, "###");
    	cout << "Your string enhanced: " << result << endl;
    	cout << "Your original string: " << input << endl;
    
    	cout << "Resetting original string.\n";
    	input = copy;
    	result = version3(input, "@@@");
    	cout << "Your string enhanced: " << result << endl;
    	cout << "Your original string: " << input << endl;
    
    	return 0;
    }
    
    string version1(const string& s1, const string& s2) {
    	string temp;
    
    	temp = s2 + s1 + s2;
    	return temp;
    }
    
    const string& version2(string& s1, const string& s2) {
    	s1 = s2 + s1 + s2;
    	return s1;
    }
    
    const string& version3(string& s1, const string& s2) {
    	string temp;
    	temp = s2 + s1 + s2;
    	return temp;
    }
    ```

* 结果：

  * ```c++
    Enter a string: It's not my fault.
    Your string as entered: It's not my fault.
    Your string enhanced: ***It's not my fault.***
    Your original string: It's not my fault.
    Your string enhanced: ###It's not my fault.###
    Your original string: ###It's not my fault.###
    Resetting original string.
    Your string enhanced:
    Your original string: It's not my fault.
    ```

  * 最后一个函数出现问题，无法正常显示：

    * version1：

      * 它接受两个 string 参数，并使用 string 类的加能来创建一个满足要求的新字符串。这两个函数参数都是 const 引用。如果使用 string 对象作为参数，最终结果将不变；
      * temp 是一个新的 string 对象，只在函数 version1() 中有效，该函数执行完毕后，它将不再存在。**因此,返回指向 temp 的引用不可行**（version3的错误），因此该函数的返回类型为 string，这意味着 temp 的内容将被复制到一个临时存储单元中，然后在 main() 中，该存储单元的内容被复制到一个名为 result 的 string 中。

    * version2：

      * 不创建临时 string 对象，而是直接修改原来的 string 对象。
      * 如果要保留原来的字符串不变，这将是一种错误设计。

    * version3：

      * 它存在一个致命的缺陷:返回一个指向 version3()中声明的变量的引用。这个函数能够通过编译(但编译器会发出警告)，但当程序试图执行该函数时将崩溃。具体地说，问题是由下面的赋值语句引发的：

        * ```c++
          result = version3(input, "@@@");
          ```

        * 程序试图引用已经释放的内存。



#### 8.2.6 对象、继承和引用
