## 第十二章 类和动态内存匹配

在类构造函数中使用new运算符在程序运行时分配所需的内存。为此，通常的方法是使用 string 类，它将为您处理内存管理细节。

### 12.1 动态内存和类

C++使用 new 和 delete 运算符来动态控制内存。但是在类中使用这些运算符将导致许多新的编程问题。因此，析构函数将是必不可少的，而不再是可有可无。

扩展析构函数、使所有的构造函数与 new 析构函数协调一致、编写额外的类方法来帮助正确完成初始化和复制。

#### 12.1.1 复习示例和静态类成员

（1）静态类成员【新的存储类型】

* 示例：

  * ```c++
    #pragma once
    // ch12_01_strngbad.h -- flawed string class definition
    #include <iostream>
    #ifndef CH12_01_STRNGBAD_H_
    #define CH12_01_STRNGBAD_H_
    
    class StringBad
    {
    private:
    	char* str;
    	int len;
    	static int num_strings;
    public:
    	StringBad(const char* s);
    	StringBad();
    	~StringBad();
    // friend function
    	friend std::ostream& operator<<(std::ostream& os, const StringBad& st);
    };
    #endif
    ```

  * 对这个声明，需要注意的有两点：

    * 首先，它使用 char 指针(而不是 char 数组)来表示姓名。这意味着类声明没有为字符串本身分配存储空间，而是在构造函数中使用 new 来为字符分配空间。这避免了在类声明中预先定义字符串的长度。
    * 其次，将 num_strings 成员声明为静态存储类。
      * 静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。也就是说，类的所有对象共享同一个静态成员，就像家中的电话可供全体家庭成员共享一样。假设创建了10个StringBad 对象，将有10个 str 成员和10个 len 成员但只有一个共享的num_strings成员(参见图 12.1)这对于所有类对都具有相同值的类私有数据是非常方便的。例如numstrings成员可以记录所创建的对象数目。
      ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/1bc29af5-e530-45a0-b8c2-7b72c629ba0a)

* 示例：类方法文件

  * ```c++
    // ch12_02_strngbad.cpp -- StringBad class methods
    #include <cstring>
    #include "ch12_01_strngbad.h"
    using std::cout;
    
    // initializing static class member
    int StringBad::num_strings = 0;
    
    // class methods
    // construct StringBad from C string
    StringBad::StringBad(const char* s)
    {
    	len = std::strlen(s);
    	str = new char[len + 1];
    	std::strcpy(str, s);
    	num_strings++;
    	cout << num_strings << ": \"" << str
    		<< "\" object created\n";
    }
    
    StringBad::StringBad()
    {
    	len = 4;
    	str = new char[4];
    	std::strcpy(str, "C++");
    	num_strings++;
    	cout << num_strings << ": \"" << str
    		<< "\" default object created\n";
    }
    
    StringBad::~StringBad()
    {
    	cout << "\"" << str << "\" object deleted, ";
    	--num_strings;
    	cout << num_strings << " left\n";
    	delete[] str;
    }
    
    std::ostream& operator <<(std::ostream& os, const StringBad& st)
    {
    	os << st.str;
    	return os;
    }
    ```

  * 静态成员num_strings的值初始化为零：

    * ```c++
      int StringBad::num_strings = 0;
      ```

    * 📌注意！不能在类声明中初始化静态成员变量：

      * 因为声明描述了如何分配内存，但并不分配内存。
      * 对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。请注意，初始化语句指出了类型，并使用了作用域运算符，但没有使用关键字static。
      * 初始化是在方法文件中，而不是在类声明文件中进行的，这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误。
      * <u>注意：静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算符来指出静态成员所属的类。但如果静态成员是整型或枚举型 const，则可以在类声明中初始化</u>

  * 不能将【std::strcpy(str, s);】改成【str = s;】，因为这只保存了地址，而没有创建字符串副本。

  * 析构函数：删除对象可以释放对象本身占用的内存，但并不能自动释放属于对象成员的指针指向的内存。因此，必须使用析构函数。在析构函数中使用 delete 语句可确保对象过期时，由构造函数使用 new 分配的内存被释放。

    * 警告❗、在构造函数中使用 new 来分配内存时，必须在相应的析构函数中使用 delete 来释放内存。如果使用new[] (包括中括号)来分配内存，则应使用 delete[] (包括中括号)来释放内存。

* 示例：

  * ```c++
    // ch12_03_vegnews.cpp -- using new and delete with classes
    // compile with strongbad.cpp
    #include <iostream>
    using std::cout;
    #include "ch12_01_strngbad.h"
    
    void callme1(StringBad&);
    void callme2(StringBad);
    
    int main()
    {
    	using std::endl;
    	{
    		cout << "Starting an inner block.\n";
    		StringBad headline1("Celery Stalks at Midnight");
    		StringBad headline2("Lettuce Prey");
    		StringBad sports("Spinach Leaves Bowl for Dollars");
    
    		cout << "headline1: " << headline1 << endl;
    		cout << "headline2: " << headline2 << endl;
    		cout << "sports: " << sports << endl;
    		
    		callme1(headline1);
    		cout << "headline1: " << headline1 << endl;
    		callme2(headline2);
    		cout << "headline2: " << headline2 << endl;
    		
    		cout << "Initialize one object to another:\n";
    		StringBad sailor = sports;
    		cout << "sailor: " << sailor << endl;
    		cout << "Assign one object to another:\n";
    		StringBad knot;
    		cout << "knot: " << knot << endl;
    		cout << "Exiting the block.\n";
    	}
    	cout << "End of main()\n";
    
    	return 0;
    }
    
    void callme1(StringBad& rsb)
    {
    	cout << "String passed by reference:\n";
    	cout << "    \"" << rsb << "\"\n";
    }
    
    void callme2(StringBad& sb)
    {
    	cout << "String passed by value:\n";
    	cout << "    \"" << sb << "\"\n";
    }
    ```

* 结果：

  * ```c++
    Starting an inner block.
    1: "Celery Stalks at Midnight" object created
    2: "Lettuce Prey" object created
    3: "Spinach Leaves Bowl for Dollars" object created
    headline1: Celery Stalks at Midnight
    headline2: Lettuce Prey
    sports: Spinach Leaves Bowl for Dollars
    String passed by reference:
        "Celery Stalks at Midnight"
    headline1: Celery Stalks at Midnight
    String passed by value:
        "Lettuce Prey"
    "Lettuce Prey" object deleted, 2 left
    headline2: 葺葺葺葺葺葺葺葺萑
    Initialize one object to another:
    sailor: Spinach Leaves Bowl for Dollars
    Assign one object to another:
    3: "C++" default object created
    knot: Celery Stalks at Midnight
    Exiting the block.
    "Celery Stalks at Midnight" object deleted, 2 left
    "Spinach Leaves Bowl for Dollars" object deleted, 1 left
    "葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺" object deleted, 0 left
    ```

  * 报错：
    * 正常，书中是在末尾对象计数为负，我使用较新的编译器和操作系统，在显示有关-1个对象的信息之前终端，因为这样的机器将报告通用保护错误（GPF）。GPF表明程序试图访问禁止它访问的内存单元，是一种糟糕的信号。
   
  * 当使用一个对象来初始化另一个对象时，编译器将自动生成上述构造函数（称为复制构造函数，因为它创建对象的一个副本）：
    * ```c++
      StringBad sailor = StringBad(sports);
      ```
    * 自动生成的构造函数不知道需要更新静态变量 num_string，因此会将计数方案搞乱。实际上，这个例子说明的所有问题都是由编译器自动生成的成员函数引起的，下面介绍这个主题。当使用一个对象来初始化另一个对象时，编译器将自动生成上述构造函数（称为复制构造函数，因为它创建对象的一个副本）：

#### 12.1.2 特殊成员函数
