## 第十二章 类和动态内存匹配

在类构造函数中使用new运算符在程序运行时分配所需的内存。为此，通常的方法是使用 string 类，它将为您处理内存管理细节。

### 12.1 动态内存和类

C++使用 new 和 delete 运算符来动态控制内存。但是在类中使用这些运算符将导致许多新的编程问题。因此，析构函数将是必不可少的，而不再是可有可无。

扩展析构函数、使所有的构造函数与 new 析构函数协调一致、编写额外的类方法来帮助正确完成初始化和复制。

#### 12.1.1 复习示例和静态类成员

（1）静态类成员【新的存储类型】

* 示例：

  * ```c++
    #pragma once
    // ch12_01_strngbad.h -- flawed string class definition
    #include <iostream>
    #ifndef CH12_01_STRNGBAD_H_
    #define CH12_01_STRNGBAD_H_
    
    class StringBad
    {
    private:
    	char* str;
    	int len;
    	static int num_strings;
    public:
    	StringBad(const char* s);
    	StringBad();
    	~StringBad();
    // friend function
    	friend std::ostream& operator<<(std::ostream& os, const StringBad& st);
    };
    #endif
    ```

  * 对这个声明，需要注意的有两点：

    * 首先，它使用 char 指针(而不是 char 数组)来表示姓名。这意味着类声明没有为字符串本身分配存储空间，而是在构造函数中使用 new 来为字符分配空间。这避免了在类声明中预先定义字符串的长度。
    * 其次，将 num_strings 成员声明为静态存储类。
      * 静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。也就是说，类的所有对象共享同一个静态成员，就像家中的电话可供全体家庭成员共享一样。假设创建了10个StringBad 对象，将有10个 str 成员和10个 len 成员但只有一个共享的num_strings成员(参见图 12.1)这对于所有类对都具有相同值的类私有数据是非常方便的。例如numstrings成员可以记录所创建的对象数目。
      ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/1bc29af5-e530-45a0-b8c2-7b72c629ba0a)

* 示例：类方法文件

  * ```c++
    // ch12_02_strngbad.cpp -- StringBad class methods
    #include <cstring>
    #include "ch12_01_strngbad.h"
    using std::cout;
    
    // initializing static class member
    int StringBad::num_strings = 0;
    
    // class methods
    // construct StringBad from C string
    StringBad::StringBad(const char* s)
    {
    	len = std::strlen(s);
    	str = new char[len + 1];
    	std::strcpy(str, s);
    	num_strings++;
    	cout << num_strings << ": \"" << str
    		<< "\" object created\n";
    }
    
    StringBad::StringBad()
    {
    	len = 4;
    	str = new char[4];
    	std::strcpy(str, "C++");
    	num_strings++;
    	cout << num_strings << ": \"" << str
    		<< "\" default object created\n";
    }
    
    StringBad::~StringBad()
    {
    	cout << "\"" << str << "\" object deleted, ";
    	--num_strings;
    	cout << num_strings << " left\n";
    	delete[] str;
    }
    
    std::ostream& operator <<(std::ostream& os, const StringBad& st)
    {
    	os << st.str;
    	return os;
    }
    ```

  * 静态成员num_strings的值初始化为零：

    * ```c++
      int StringBad::num_strings = 0;
      ```

    * 📌注意！不能在类声明中初始化静态成员变量：

      * 因为声明描述了如何分配内存，但并不分配内存。
      * 对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。请注意，初始化语句指出了类型，并使用了作用域运算符，但没有使用关键字static。
      * 初始化是在方法文件中，而不是在类声明文件中进行的，这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误。
      * <u>注意：静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算符来指出静态成员所属的类。但如果静态成员是整型或枚举型 const，则可以在类声明中初始化</u>

  * 不能将【std::strcpy(str, s);】改成【str = s;】，因为这只保存了地址，而没有创建字符串副本。

  * 析构函数：删除对象可以释放对象本身占用的内存，但并不能自动释放属于对象成员的指针指向的内存。因此，必须使用析构函数。在析构函数中使用 delete 语句可确保对象过期时，由构造函数使用 new 分配的内存被释放。

    * 警告❗、在构造函数中使用 new 来分配内存时，必须在相应的析构函数中使用 delete 来释放内存。如果使用new[] (包括中括号)来分配内存，则应使用 delete[] (包括中括号)来释放内存。

* 示例：

  * ```c++
    // ch12_03_vegnews.cpp -- using new and delete with classes
    // compile with strongbad.cpp
    #include <iostream>
    using std::cout;
    #include "ch12_01_strngbad.h"
    
    void callme1(StringBad&);
    void callme2(StringBad);
    
    int main()
    {
    	using std::endl;
    	{
    		cout << "Starting an inner block.\n";
    		StringBad headline1("Celery Stalks at Midnight");
    		StringBad headline2("Lettuce Prey");
    		StringBad sports("Spinach Leaves Bowl for Dollars");
    
    		cout << "headline1: " << headline1 << endl;
    		cout << "headline2: " << headline2 << endl;
    		cout << "sports: " << sports << endl;
    		
    		callme1(headline1);
    		cout << "headline1: " << headline1 << endl;
    		callme2(headline2);
    		cout << "headline2: " << headline2 << endl;
    		
    		cout << "Initialize one object to another:\n";
    		StringBad sailor = sports;
    		cout << "sailor: " << sailor << endl;
    		cout << "Assign one object to another:\n";
    		StringBad knot;
    		cout << "knot: " << knot << endl;
    		cout << "Exiting the block.\n";
    	}
    	cout << "End of main()\n";
    
    	return 0;
    }
    
    void callme1(StringBad& rsb)
    {
    	cout << "String passed by reference:\n";
    	cout << "    \"" << rsb << "\"\n";
    }
    
    void callme2(StringBad& sb)
    {
    	cout << "String passed by value:\n";
    	cout << "    \"" << sb << "\"\n";
    }
    ```

* 结果：

  * ```c++
    Starting an inner block.
    1: "Celery Stalks at Midnight" object created
    2: "Lettuce Prey" object created
    3: "Spinach Leaves Bowl for Dollars" object created
    headline1: Celery Stalks at Midnight
    headline2: Lettuce Prey
    sports: Spinach Leaves Bowl for Dollars
    String passed by reference:
        "Celery Stalks at Midnight"
    headline1: Celery Stalks at Midnight
    String passed by value:
        "Lettuce Prey"
    "Lettuce Prey" object deleted, 2 left
    headline2: 葺葺葺葺葺葺葺葺萑
    Initialize one object to another:
    sailor: Spinach Leaves Bowl for Dollars
    Assign one object to another:
    3: "C++" default object created
    knot: Celery Stalks at Midnight
    Exiting the block.
    "Celery Stalks at Midnight" object deleted, 2 left
    "Spinach Leaves Bowl for Dollars" object deleted, 1 left
    "葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺" object deleted, 0 left
    ```

  * 报错：
    * 正常，书中是在末尾对象计数为负，我使用较新的编译器和操作系统，在显示有关-1个对象的信息之前终端，因为这样的机器将报告通用保护错误（GPF）。GPF表明程序试图访问禁止它访问的内存单元，是一种糟糕的信号。
   
  * 当使用一个对象来初始化另一个对象时，编译器将自动生成上述构造函数（称为复制构造函数，因为它创建对象的一个副本）：
    * ```c++
      StringBad sailor = StringBad(sports);
      ```
    * 自动生成的构造函数不知道需要更新静态变量 num_string，因此会将计数方案搞乱。实际上，这个例子说明的所有问题都是由编译器自动生成的成员函数引起的，下面介绍这个主题。当使用一个对象来初始化另一个对象时，编译器将自动生成上述构造函数（称为复制构造函数，因为它创建对象的一个副本）：

#### 12.1.2 特殊成员函数

StringBad类的问题是由特殊成员函数造成的。C++自动提供了下面这些成员函数：

* 默认构造函数，如果没有定义构造函数；
* 默认析构函数，如果没有定义；
* 复制构造函数，如果没有定义；
* 赋值运算符，如果没有定义；
* 地址运算符，如果没有定义。

StringBad类中的问题是由隐式复制构造函数和隐式赋值运算符引起的。

1、默认构造函数

* 如果没有提供任何构造函数，C++将创建默认构造函数：

  * ```c++
    Klunk::Klunk() { }
    ```

  * 也就是说，编译器将提供一个不接受任何参数，也不执行任何操作的构造函数(默认的默认构造函数)，这是因为创建对象时总是会调用构造函数：

    * ```C++
      Klunk lunk;
      ```

* 如果定义了构造函数，C++将不会定义默认构造函数。如果希望在创建对象时不显式地对它进行初始化，则必须显式地定义默认构造函数。这种构造函数没有任何参数，但可以使用它来设置特定的值：

  * ```c++
    klunk::klunk()
    {
        klunk_ct = 0;
        ...
    }
    ```

  * 带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值:

    * ```c++
      Klunk(int n = 0) { klunk_ct = n; }
      ```

  * 但只能有一个默认构造函数，见P433

2、复制构造函数

* 复制构造函数用于将一个对象复制到新创建的对象中。也就是说，它用于初始化过程中(包括按值传递参数)，而不是常规的赋值过程中。类的复制构造函数原型通常如下：

  * ```c++
    Class_name(const Class_name &);
    ```

  * 它接受一个指向类对象的常量引用作为参数；

  * 对于复制构造函数，需要知道两点：

    * 何时调用复制构造函数

      * 新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。这在很多情况下都可能发生，最常见的情况是将新对象显式地初始化为现有的对象。
      * 每当程序生成了对象副本时，编译器都将使用复制构造函数。
        * 具体地说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。
        * 由于按值传递对象将调用复制构造函数，因此应该按引用传递对象。这样可以节省调用构造函数的时间以及存储新对象的空间。

    * 默认的复制构造函数的功能

      * 默认的复制构造函数逐个复制非静态成员(成员复制也称为浅复制)，复制的是成员的值：

        * ```c++
          StringBad sailor = sports;
          // 与下面代码等效：
          StringBad sailor;
          sailor.str = sports.str;
          sailor.len = sports.len;
          ```

      * 如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。静态函数(如 num_strings )不受影响，因为它们属于整个类，而不是各个对象。图 12.2 说明了隐式复制构造函数执行的操作。

        * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/c77de957-0bd3-4a03-8c11-634279641fa7)

#### 12.1.3 回到 StringBad：复制构造函数的哪里出了问题

程序清单12.3两个异常之处：

（1）程序输出表明，析构函数的调用次数比构造函数的调用次数多2，原因可能是程序确实使用默认的复制构造函数另外创建了两个对象。

* 解决办法：提供一个对计数进行更新的显式复制构造函数：

  * ```C++
    StringBad::StringBad(const String & s)
    {
        num_strings++;
        ...
    }
    ```

  * ❗如果类中包含这样的**静态数据成员**，即其值将在新对象被创建时发生变化，则应该提供一个**显式复制构造函数**来处理计数问题。

（2）字符串内容出现乱码：

* 原因在于隐式复制构造函数是按值进行复制的。

  * ```c++
    sailor.str = sport.str;
    ```

  * 这里复制的并不是字符串，而是一个指向字符串的指针。当析构函数被调用是，析构函数释放复制类后指针指向的内存，但是指向的内存之前已经被本体的析构函数释放了，这将导致不确定的、可能有害的后果。

（3）定义一个显式复制构造函数以解决问题：

* 深度复制：复制构造函数应当复制字符串并将副本的地址赋给str成员，而不仅仅是复制字符串地址。

  * 这样每个对象都有自己的字符串，而不是引用另一个对象的字符串。

  * 调用析构函数时都将释放不同的字符串，而不会试图去释放已经被释放的字符串。

  * 可以这样编写String的复制构造函数：

    * ```c++
      StringBad::StringBad(const StringBad & st)
      {
          num_strings++;
          len = st.len;
          str = new char[len + 1];
          std::strcpy(str, st.str);
          cout << num_strings << ": \" << str <<"\" object created\n";
      }
      ```

  * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/7d300f0f-c9e7-4050-8f4f-906829b70fa4)

  * 如果类中包含了使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而不是指针，这被称为深度复制。

#### 12.1.4 StringBad 的其他问题：赋值运算符

C++允许类对象赋值，这是通过自动为类重载赋值运算符实现的：

* ```c++
  Class_name & Class_name::operator=(const Class_name &);
  ```

* 它接受并返回一个指向类对象的引用。

（1）赋值运算符的功能以及何时使用它

* 将已有的对象赋给另一个对象时，将使用重载的赋值运算符；
* 初始化对象时，并不一定会使用赋值运算符。
* 与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制。如果成员本身就是类对象，则程序将使用为这个类定义的赋值运算符来复制该成员，但静态数据成员不受影响。

（2）赋值的问题出在哪里

* 出现的问题与隐式复制构造函数相同：数据受损。

（3）解决赋值的问题

* 提供赋值运算符（进行深度复制）的定义，其实现与复制构造函数相似，也存在一些差别：

  * 由于目标对象可能引用了以前分配的数据，所以函数应使用 delete[ ]来释放这些数据。
  * 函数应当避免将对象赋给自身；否则，给对象重新赋值前，释放内存操作可能删除对象的内容。
  * 函数返回一个指向调用对象的引用。

* ```c++
  StringBad & StringBad::operator=(const StringBad & st)
  {
      if(this == &st)
          return *this;
      delete [] str;
      len = st.len;
      str = new char [len + 1];
      std::strcpy(str, st.str);
      return *this;
  }
  ```

* 赋值操作并不创建新的对象，因此不需要调整静态数据成员num_strings的值。



### 12.2 改进后的新 String 类

（1）添加**复制构造函数**和**赋值运算符**，使类能够正确管理类对象使用的内存。

（2）根据对象何时被创建和释放，可以让构造函数和析构函数保持沉默，不再在每次被调用时都显示消息。

（3）不用再监视构造函数的工作情况，因此可以简化默认构造函数，使之创建一个空字符串，而不是"C++"。

#### 12.2.1 修订后的默认构造函数

* ```c++
  String::String()
  {
      len = 0;
      str = new char[1];//与类析构函数兼容，而后者不兼容，见P438
      str[0] = '\0';
  }
  ```

* C++空指针，关键字nullptr，凯南P438

  * ```c++
    str = nullpter;
    ```

#### 12.2.2 比较成员函数

* 执行比较操作的方法有三种：<、>和==，实现字符串在前在后的比较：

  * ```c++
    bool operator<(const String &st1, const String &st2)
    {
        return(std::strcmp(st1.str, st2.str) < 0);
    }
    ```

  * 另外两个可以用同样的方式来编写。

#### 12.2.3 使用中括号表示法访问字符

* 在C++中，两个中括号组成一个运算符——中括号运算符，可以使用方法operator[ ] ( )来重载该运算符。

  * 通常，二元C++运算符（带两个操作数）位于两个操作数之间，例如2+5。但对于中括号运算符，一个操作数位于第一个中括号的前面，两一个位于两个中括号之间。
  * 因此在表达式city[0]中，city是第一个操作数，[]是运算符，0是第二个操作数：

* 公有方法可以访问私有数据，并给特定的元素赋值：

  * ```c++
    char & String::operator [] (int i)
    {
        return str[i];
    }
    ```

  * 返回值是xxx.str[4]。因此公有方法可以访问私有数据。

  * 将返回类型声明为char &，便可以给特定的元素赋值：

    * ```c++
      String means("might");
      means[0] = 'r';
      ```

* 对于常量对象，上述方法将出错。因为在重载时C++将区分常量和非常量函数的特征标，因此可以提供另一个仅供const String对象使用的operator[ ] ( )版本：

  * ```c++
    const char & String::operator [] (int i) const
    {
        return str[i];
    }
    ```

#### 12.2.4 静态类成员函数

* 可以将成员函数声明为静态的后果：

  * 1、不能通过对象调用静态成员函数，甚至不能使用this指针。

    * 如果静态成员函数是在公有部分声明的，则可以使用类名和作用域解析运算符来调用它：

      * ```C++
        static int HowMany() {return num_strings;}
        int count = String::HowMany;
        ```

  * 2、由于静态成员函数不与特定的对象相关联，因此只能使用静态数据成员。

    * 例如静态方法HowMany()可以访问静态成员 num_string，但不能访问str和len。

#### 12.2.5 进一步重载赋值运算符

* 将常规字符串复制到String对象中，往往效率不高，见P439。为了提高处理效率，最简单的方法是重载赋值运算符，使之能够直接使用常规字符串，这样就不用创建和删除临时对象了。

  * ```c++
    String & String::operator=(const char * s)
    {
        delete [] str;
        len = std::strlens(s);
        str = new char[len + 1];
        std::strcpy(str, s);
        return *this;
    }
    ```

  * 一般来说必须释放str指向的内存，并为新字符串分配足够的内存。

#### 12.2.6 程序清单
