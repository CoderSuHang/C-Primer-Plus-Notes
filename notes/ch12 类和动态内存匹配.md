## 第十二章 类和动态内存匹配

在类构造函数中使用new运算符在程序运行时分配所需的内存。为此，通常的方法是使用 string 类，它将为您处理内存管理细节。

### 12.1 动态内存和类

C++使用 new 和 delete 运算符来动态控制内存。但是在类中使用这些运算符将导致许多新的编程问题。因此，析构函数将是必不可少的，而不再是可有可无。

扩展析构函数、使所有的构造函数与 new 析构函数协调一致、编写额外的类方法来帮助正确完成初始化和复制。

#### 12.1.1 复习示例和静态类成员

（1）静态类成员【新的存储类型】

* 示例：

  * ```c++
    #pragma once
    // ch12_01_strngbad.h -- flawed string class definition
    #include <iostream>
    #ifndef CH12_01_STRNGBAD_H_
    #define CH12_01_STRNGBAD_H_
    
    class StringBad
    {
    private:
    	char* str;
    	int len;
    	static int num_strings;
    public:
    	StringBad(const char* s);
    	StringBad();
    	~StringBad();
    // friend function
    	friend std::ostream& operator<<(std::ostream& os, const StringBad& st);
    };
    #endif
    ```

  * 对这个声明，需要注意的有两点：

    * 首先，它使用 char 指针(而不是 char 数组)来表示姓名。这意味着类声明没有为字符串本身分配存储空间，而是在构造函数中使用 new 来为字符分配空间。这避免了在类声明中预先定义字符串的长度。
    * 其次，将 num_strings 成员声明为静态存储类。
      * 静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。也就是说，类的所有对象共享同一个静态成员，就像家中的电话可供全体家庭成员共享一样。假设创建了10个StringBad 对象，将有10个 str 成员和10个 len 成员但只有一个共享的num_strings成员(参见图 12.1)这对于所有类对都具有相同值的类私有数据是非常方便的。例如numstrings成员可以记录所创建的对象数目。
      ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/1bc29af5-e530-45a0-b8c2-7b72c629ba0a)

* 示例：类方法文件

  * ```c++
    // ch12_02_strngbad.cpp -- StringBad class methods
    #include <cstring>
    #include "ch12_01_strngbad.h"
    using std::cout;
    
    // initializing static class member
    int StringBad::num_strings = 0;
    
    // class methods
    // construct StringBad from C string
    StringBad::StringBad(const char* s)
    {
    	len = std::strlen(s);
    	str = new char[len + 1];
    	std::strcpy(str, s);
    	num_strings++;
    	cout << num_strings << ": \"" << str
    		<< "\" object created\n";
    }
    
    StringBad::StringBad()
    {
    	len = 4;
    	str = new char[4];
    	std::strcpy(str, "C++");
    	num_strings++;
    	cout << num_strings << ": \"" << str
    		<< "\" default object created\n";
    }
    
    StringBad::~StringBad()
    {
    	cout << "\"" << str << "\" object deleted, ";
    	--num_strings;
    	cout << num_strings << " left\n";
    	delete[] str;
    }
    
    std::ostream& operator <<(std::ostream& os, const StringBad& st)
    {
    	os << st.str;
    	return os;
    }
    ```

  * 静态成员num_strings的值初始化为零：

    * ```c++
      int StringBad::num_strings = 0;
      ```

    * 📌注意！不能在类声明中初始化静态成员变量：

      * 因为声明描述了如何分配内存，但并不分配内存。
      * 对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。请注意，初始化语句指出了类型，并使用了作用域运算符，但没有使用关键字static。
      * 初始化是在方法文件中，而不是在类声明文件中进行的，这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误。
      * <u>注意：静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算符来指出静态成员所属的类。但如果静态成员是整型或枚举型 const，则可以在类声明中初始化</u>

  * 不能将【std::strcpy(str, s);】改成【str = s;】，因为这只保存了地址，而没有创建字符串副本。

  * 析构函数：删除对象可以释放对象本身占用的内存，但并不能自动释放属于对象成员的指针指向的内存。因此，必须使用析构函数。在析构函数中使用 delete 语句可确保对象过期时，由构造函数使用 new 分配的内存被释放。

    * 警告❗、在构造函数中使用 new 来分配内存时，必须在相应的析构函数中使用 delete 来释放内存。如果使用new[] (包括中括号)来分配内存，则应使用 delete[] (包括中括号)来释放内存。

* 示例：

  * ```c++
    // ch12_03_vegnews.cpp -- using new and delete with classes
    // compile with strongbad.cpp
    #include <iostream>
    using std::cout;
    #include "ch12_01_strngbad.h"
    
    void callme1(StringBad&);
    void callme2(StringBad);
    
    int main()
    {
    	using std::endl;
    	{
    		cout << "Starting an inner block.\n";
    		StringBad headline1("Celery Stalks at Midnight");
    		StringBad headline2("Lettuce Prey");
    		StringBad sports("Spinach Leaves Bowl for Dollars");
    
    		cout << "headline1: " << headline1 << endl;
    		cout << "headline2: " << headline2 << endl;
    		cout << "sports: " << sports << endl;
    		
    		callme1(headline1);
    		cout << "headline1: " << headline1 << endl;
    		callme2(headline2);
    		cout << "headline2: " << headline2 << endl;
    		
    		cout << "Initialize one object to another:\n";
    		StringBad sailor = sports;
    		cout << "sailor: " << sailor << endl;
    		cout << "Assign one object to another:\n";
    		StringBad knot;
    		cout << "knot: " << knot << endl;
    		cout << "Exiting the block.\n";
    	}
    	cout << "End of main()\n";
    
    	return 0;
    }
    
    void callme1(StringBad& rsb)
    {
    	cout << "String passed by reference:\n";
    	cout << "    \"" << rsb << "\"\n";
    }
    
    void callme2(StringBad& sb)
    {
    	cout << "String passed by value:\n";
    	cout << "    \"" << sb << "\"\n";
    }
    ```

* 结果：

  * ```c++
    Starting an inner block.
    1: "Celery Stalks at Midnight" object created
    2: "Lettuce Prey" object created
    3: "Spinach Leaves Bowl for Dollars" object created
    headline1: Celery Stalks at Midnight
    headline2: Lettuce Prey
    sports: Spinach Leaves Bowl for Dollars
    String passed by reference:
        "Celery Stalks at Midnight"
    headline1: Celery Stalks at Midnight
    String passed by value:
        "Lettuce Prey"
    "Lettuce Prey" object deleted, 2 left
    headline2: 葺葺葺葺葺葺葺葺萑
    Initialize one object to another:
    sailor: Spinach Leaves Bowl for Dollars
    Assign one object to another:
    3: "C++" default object created
    knot: Celery Stalks at Midnight
    Exiting the block.
    "Celery Stalks at Midnight" object deleted, 2 left
    "Spinach Leaves Bowl for Dollars" object deleted, 1 left
    "葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺葺" object deleted, 0 left
    ```

  * 报错：
    * 正常，书中是在末尾对象计数为负，我使用较新的编译器和操作系统，在显示有关-1个对象的信息之前终端，因为这样的机器将报告通用保护错误（GPF）。GPF表明程序试图访问禁止它访问的内存单元，是一种糟糕的信号。
   
  * 当使用一个对象来初始化另一个对象时，编译器将自动生成上述构造函数（称为复制构造函数，因为它创建对象的一个副本）：
    * ```c++
      StringBad sailor = StringBad(sports);
      ```
    * 自动生成的构造函数不知道需要更新静态变量 num_string，因此会将计数方案搞乱。实际上，这个例子说明的所有问题都是由编译器自动生成的成员函数引起的，下面介绍这个主题。当使用一个对象来初始化另一个对象时，编译器将自动生成上述构造函数（称为复制构造函数，因为它创建对象的一个副本）：

#### 12.1.2 特殊成员函数

StringBad类的问题是由特殊成员函数造成的。C++自动提供了下面这些成员函数：

* 默认构造函数，如果没有定义构造函数；
* 默认析构函数，如果没有定义；
* 复制构造函数，如果没有定义；
* 赋值运算符，如果没有定义；
* 地址运算符，如果没有定义。

StringBad类中的问题是由隐式复制构造函数和隐式赋值运算符引起的。

1、默认构造函数

* 如果没有提供任何构造函数，C++将创建默认构造函数：

  * ```c++
    Klunk::Klunk() { }
    ```

  * 也就是说，编译器将提供一个不接受任何参数，也不执行任何操作的构造函数(默认的默认构造函数)，这是因为创建对象时总是会调用构造函数：

    * ```C++
      Klunk lunk;
      ```

* 如果定义了构造函数，C++将不会定义默认构造函数。如果希望在创建对象时不显式地对它进行初始化，则必须显式地定义默认构造函数。这种构造函数没有任何参数，但可以使用它来设置特定的值：

  * ```c++
    klunk::klunk()
    {
        klunk_ct = 0;
        ...
    }
    ```

  * 带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值:

    * ```c++
      Klunk(int n = 0) { klunk_ct = n; }
      ```

  * 但只能有一个默认构造函数，见P433

2、复制构造函数

* 复制构造函数用于将一个对象复制到新创建的对象中。也就是说，它用于初始化过程中(包括按值传递参数)，而不是常规的赋值过程中。类的复制构造函数原型通常如下：

  * ```c++
    Class_name(const Class_name &);
    ```

  * 它接受一个指向类对象的常量引用作为参数；

  * 对于复制构造函数，需要知道两点：

    * 何时调用复制构造函数

      * 新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。这在很多情况下都可能发生，最常见的情况是将新对象显式地初始化为现有的对象。
      * 每当程序生成了对象副本时，编译器都将使用复制构造函数。
        * 具体地说，当函数按值传递对象或函数返回对象时，都将使用复制构造函数。
        * 由于按值传递对象将调用复制构造函数，因此应该按引用传递对象。这样可以节省调用构造函数的时间以及存储新对象的空间。

    * 默认的复制构造函数的功能

      * 默认的复制构造函数逐个复制非静态成员(成员复制也称为浅复制)，复制的是成员的值：

        * ```c++
          StringBad sailor = sports;
          // 与下面代码等效：
          StringBad sailor;
          sailor.str = sports.str;
          sailor.len = sports.len;
          ```

      * 如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。静态函数(如 num_strings )不受影响，因为它们属于整个类，而不是各个对象。图 12.2 说明了隐式复制构造函数执行的操作。

        * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/c77de957-0bd3-4a03-8c11-634279641fa7)

#### 12.1.3 回到 StringBad：复制构造函数的哪里出了问题

程序清单12.3两个异常之处：

（1）程序输出表明，析构函数的调用次数比构造函数的调用次数多2，原因可能是程序确实使用默认的复制构造函数另外创建了两个对象。

* 解决办法：提供一个对计数进行更新的显式复制构造函数：

  * ```C++
    StringBad::StringBad(const String & s)
    {
        num_strings++;
        ...
    }
    ```

  * ❗如果类中包含这样的**静态数据成员**，即其值将在新对象被创建时发生变化，则应该提供一个**显式复制构造函数**来处理计数问题。

（2）字符串内容出现乱码：

* 原因在于隐式复制构造函数是按值进行复制的。

  * ```c++
    sailor.str = sport.str;
    ```

  * 这里复制的并不是字符串，而是一个指向字符串的指针。当析构函数被调用是，析构函数释放复制类后指针指向的内存，但是指向的内存之前已经被本体的析构函数释放了，这将导致不确定的、可能有害的后果。

（3）定义一个显式复制构造函数以解决问题：

* 深度复制：复制构造函数应当复制字符串并将副本的地址赋给str成员，而不仅仅是复制字符串地址。

  * 这样每个对象都有自己的字符串，而不是引用另一个对象的字符串。

  * 调用析构函数时都将释放不同的字符串，而不会试图去释放已经被释放的字符串。

  * 可以这样编写String的复制构造函数：

    * ```c++
      StringBad::StringBad(const StringBad & st)
      {
          num_strings++;
          len = st.len;
          str = new char[len + 1];
          std::strcpy(str, st.str);
          cout << num_strings << ": \" << str <<"\" object created\n";
      }
      ```

  * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/7d300f0f-c9e7-4050-8f4f-906829b70fa4)

  * 如果类中包含了使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而不是指针，这被称为深度复制。

#### 12.1.4 StringBad 的其他问题：赋值运算符

C++允许类对象赋值，这是通过自动为类重载赋值运算符实现的：

* ```c++
  Class_name & Class_name::operator=(const Class_name &);
  ```

* 它接受并返回一个指向类对象的引用。

（1）赋值运算符的功能以及何时使用它

* 将已有的对象赋给另一个对象时，将使用重载的赋值运算符；
* 初始化对象时，并不一定会使用赋值运算符。
* 与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制。如果成员本身就是类对象，则程序将使用为这个类定义的赋值运算符来复制该成员，但静态数据成员不受影响。

（2）赋值的问题出在哪里

* 出现的问题与隐式复制构造函数相同：数据受损。

（3）解决赋值的问题

* 提供赋值运算符（进行深度复制）的定义，其实现与复制构造函数相似，也存在一些差别：

  * 由于目标对象可能引用了以前分配的数据，所以函数应使用 delete[ ]来释放这些数据。
  * 函数应当避免将对象赋给自身；否则，给对象重新赋值前，释放内存操作可能删除对象的内容。
  * 函数返回一个指向调用对象的引用。

* ```c++
  StringBad & StringBad::operator=(const StringBad & st)
  {
      if(this == &st)
          return *this;
      delete [] str;
      len = st.len;
      str = new char [len + 1];
      std::strcpy(str, st.str);
      return *this;
  }
  ```

* 赋值操作并不创建新的对象，因此不需要调整静态数据成员num_strings的值。



### 12.2 改进后的新 String 类

（1）添加**复制构造函数**和**赋值运算符**，使类能够正确管理类对象使用的内存。

（2）根据对象何时被创建和释放，可以让构造函数和析构函数保持沉默，不再在每次被调用时都显示消息。

（3）不用再监视构造函数的工作情况，因此可以简化默认构造函数，使之创建一个空字符串，而不是"C++"。

#### 12.2.1 修订后的默认构造函数

* ```c++
  String::String()
  {
      len = 0;
      str = new char[1];//与类析构函数兼容，而后者不兼容，见P438
      str[0] = '\0';
  }
  ```

* C++空指针，关键字nullptr，凯南P438

  * ```c++
    str = nullpter;
    ```

#### 12.2.2 比较成员函数

* 执行比较操作的方法有三种：<、>和==，实现字符串在前在后的比较：

  * ```c++
    bool operator<(const String &st1, const String &st2)
    {
        return(std::strcmp(st1.str, st2.str) < 0);
    }
    ```

  * 另外两个可以用同样的方式来编写。

#### 12.2.3 使用中括号表示法访问字符

* 在C++中，两个中括号组成一个运算符——中括号运算符，可以使用方法operator[ ] ( )来重载该运算符。

  * 通常，二元C++运算符（带两个操作数）位于两个操作数之间，例如2+5。但对于中括号运算符，一个操作数位于第一个中括号的前面，两一个位于两个中括号之间。
  * 因此在表达式city[0]中，city是第一个操作数，[]是运算符，0是第二个操作数：

* 公有方法可以访问私有数据，并给特定的元素赋值：

  * ```c++
    char & String::operator [] (int i)
    {
        return str[i];
    }
    ```

  * 返回值是xxx.str[4]。因此公有方法可以访问私有数据。

  * 将返回类型声明为char &，便可以给特定的元素赋值：

    * ```c++
      String means("might");
      means[0] = 'r';
      ```

* 对于常量对象，上述方法将出错。因为在重载时C++将区分常量和非常量函数的特征标，因此可以提供另一个仅供const String对象使用的operator[ ] ( )版本：

  * ```c++
    const char & String::operator [] (int i) const
    {
        return str[i];
    }
    ```

#### 12.2.4 静态类成员函数

* 可以将成员函数声明为静态的后果：

  * 1、不能通过对象调用静态成员函数，甚至不能使用this指针。

    * 如果静态成员函数是在公有部分声明的，则可以使用类名和作用域解析运算符来调用它：

      * ```C++
        static int HowMany() {return num_strings;}
        int count = String::HowMany;
        ```

  * 2、由于静态成员函数不与特定的对象相关联，因此只能使用静态数据成员。

    * 例如静态方法HowMany()可以访问静态成员 num_string，但不能访问str和len。

#### 12.2.5 进一步重载赋值运算符

* 将常规字符串复制到String对象中，往往效率不高，见P439。为了提高处理效率，最简单的方法是重载赋值运算符，使之能够直接使用常规字符串，这样就不用创建和删除临时对象了。

  * ```c++
    String & String::operator=(const char * s)
    {
        delete [] str;
        len = std::strlens(s);
        str = new char[len + 1];
        std::strcpy(str, s);
        return *this;
    }
    ```

  * 一般来说必须释放str指向的内存，并为新字符串分配足够的内存。

#### 12.2.6 程序清单

* 示例：类声明

  * ```c++
    #pragma once
    // ch12_04_string1.h -- fixed and augmented string class definition
    #ifndef CH12_04_STRING1_H_
    #define CH12_04_STRING1_H_
    #include <iostream>
    using std::ostream;
    using std::istream;
    
    class String
    {
    private:
    	char* str;
    	int len;
    	static int num_strings;
    	static const int CINLIM = 80;
    public:
    	String(const char* s);
    	String();
    	String(const String&);
    	~String();
    	int length() const { return len; }
    // overloaded operator methods
    	String& operator=(const String&);
    	String& operator=(const char*);
    	char& operator[](int i);
    	const char& operator[](int i)const;
    // overloaded operator friends
    	friend bool operator<(const String& st, const String& st2);
    	friend bool operator>(const String& st, const String& st2);
    	friend bool operator==(const String& st, const String& st2);
    	friend ostream& operator<<(ostream& os, const String& st);
    	friend istream& operator>>(istream& is, String& st);
    // static function
    	static int HowMany();
    };
    #endif
    ```

* 示例：类方法定义 

  * ```c++
    #define _CRT_SECURE_NO_WARNINGS
    // ch12_05_string1.cpp -- String class methods
    #include <cstring>
    #include "ch12_04_string1.h"
    using std::cin;
    using std::cout;
    
    // initializing static class member
    int String::num_strings = 0;
    
    // static method
    int String::HowMany()
    {
    	return num_strings;
    }
    
    // class methods
    // construct StringBad from C string
    String::String(const char* s)
    {
    	len = std::strlen(s);
    	str = new char[len + 1];
    	std::strcpy(str, s);
    	num_strings++;
    }
    
    String::String()
    {
    	len = 4;
    	str = new char[1];
    	str[0] = '\0';
    	num_strings++;
    }
    
    String::String(const String& st)
    {
    	num_strings++;
    	len = st.len;
    	str = new char[len + 1];
    	std::strcpy(str, st.str);
    }
    
    String::~String()
    {
    	--num_strings;
    	delete[] str;
    }
    
    // overloaded operator methods
    	// assign a String to a String
    String& String::operator=(const String& st)
    {
    	if (this == &st)
    		return *this;
    	delete[] str;
    	len = st.len;
    	str = new char[len + 1];
    	std::strcpy(str, st.str);
    	return *this;
    }
    
    	// assign a C string to a string
    String& String::operator=(const char* s)
    {
    	delete[] str;
    	len = std::strlen(s);
    	str = new char[len + 1];
    	std::strcpy(str, s);
    	return *this;
    }
    
    	// read-write char access for non-const String
    char& String::operator[](int i)
    {
    	return str[i];
    }
    
    	// read-only char access for const String
    const char& String::operator[](int i) const
    {
    	return str[i];
    }
    
    // overload operator friends
    
    bool operator<(const String& st1, const String& st2)
    {
    	return(std::strcmp(st1.str, st2.str) < 0);
    }
    
    bool operator>(const String& st1, const String& st2)
    {
    	return st2 < st1;
    }
    
    bool operator==(const String& st1, const String& st2)
    {
    	return(std::strcmp(st1.str, st2.str) == 0);
    }
    
    	// simple String output
    ostream& operator<<(ostream& os, const String& st)
    {
    	os << st.str;
    	return os;
    }
    
    	// quick and dirty String input
    istream& operator>>(istream& is, String& st)
    {
    	char temp[String::CINLIM];
    	is.get(temp, String::CINLIM);
    	if (is)
    		st = temp;
    	while (is && is.get() != '\n')
    		continue;
    	return is;
    }
    ```

* 示例：（方法使用）

  * ```c++
    // ch12_06_sayings1.cpp -- using expanded String class
    // compile with ch12_06_sayings1.cpp
    #include <iostream>
    #include "ch12_04_string1.h"
    
    const int ArSize = 10;
    const int MaxLen = 81;
    
    int main()
    {
    	using std::cout;
    	using std::cin;
    	using std::endl;
    
    	String name;
    	cout << "Hi, what's your name?\n>> ";
    	cin >> name;
    
    	cout << name << ", please enter up to " << ArSize
    		<< " short sayings <empty line to quit>:\n";
    	String sayings[ArSize];
    	char temp[MaxLen];
    	int i;
    	for (i = 0; i < ArSize; i++)
    	{
    		cout << i + 1 << ": ";
    		cin.get(temp, MaxLen);
    		while (cin && cin.get() != '\n')
    			continue;
    		if (!cin || temp[0] == '\0')	//empty line?
    			break;
    		else
    			sayings[i] = temp;
    	}
    	int total = i;
    
    	if (total > 0)
    	{
    		cout << "Here are your sayings:\n";
    		for (i = 0; i < total; i++)
    			cout << sayings[i][0] << ": " << sayings[i] << endl;
    
    		int shortest = 0;
    		int first = 0;
    		for (i = 1; i < total; i++)
    		{
    			if (sayings[i].length() < sayings[shortest].length())
    				shortest = i;
    			if (sayings[i] < sayings[first])
    				first = i;
    		}
    		cout << "Shortest saying:\n" << sayings[shortest] << endl;
    		cout << "First alphabetically:\n" << sayings[first] << endl;
    		cout << "This program used " << String::HowMany()
    			<< " String objects. Bye.\n";
    	}
    	else
    		cout << "No input! Bye.\n";
    	return 0;
    
    }
    ```

* 结果：

  * ```c++
    Hi, what's your name?
    >> Misty Gutz
    Misty Gutz, please enter up to 10 short sayings <empty line to quit>:
    1: a fool and his money are soon parted
    2: penny wise, pound foolish
    3: the love of money is the root of much evil
    4: out of sight, out of mind
    5: absence makes the heart grow fonder
    6: absinthe makes the hart grow fonder
    7:
    Here are your sayings:
    a: a fool and his money are soon parted
    p: penny wise, pound foolish
    t: the love of money is the root of much evil
    o: out of sight, out of mind
    a: absence makes the heart grow fonder
    a: absinthe makes the hart grow fonder
    Shortest saying:
    penny wise, pound foolish
    First alphabetically:
    a fool and his money are soon parted
    This program used 11 String objects. Bye.
    ```

### 12.3 在构造函数中使用new时应注意的事项

* 如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete。

* new 和 delete 必须相互兼容。new 对应于 delete， new[ ] 对应于 delete[ ]。

* 如果有多个构造函数，则必须以相同的方式使用 new，要么都带中括号，要么都不带。因为只有一个析构函数，所有的函数都必须与它兼容。然而可以在一个构造函数中使用 new 初始化指针，而在另一个构造函数中将指针初始化为空，这是因为 delete 可以用于空指针。

* 应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。

  * ```C++
    String::String(const String& st)
    {
    	num_strings++;
    	len = st.len;
    	str = new char[len + 1];
    	std::strcpy(str, st.str);
    }
    ```

  * 具体地说，复制构造函数应分配足够的空间来储存复制地值，并复制数据，而不仅仅是数据的地址。另外，还应该更新所受影响的静态类成员。

* 应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象。

  * ```c++
    String& String::operator=(const String& st)
    {
    	if (this == &st)
    		return *this;
    	delete[] str;
    	len = st.len;
    	str = new char[len + 1];
    	std::strcpy(str, st.str);
    	return *this;
    }
    ```

  * 具体地说，该方法应完成这些操作：检查自我赋值的情况，释放成员指针以前指向的内存，复制数据而不仅仅是数据的地址，并返回一个指向调用对象的引用。

#### 12.3.1 应该和不应该

* 包括以上注意事项的示例，见P448

#### 12.3.2 包含类成员的类的逐成员复制

* 是否要为其他类编写复制构造函数和赋值运算符？不，至少对某些类来说不需要。见P449。

### 12.4 有关返回对象的说明

当成员函数或独立的函数返回对象时，有几种返回方式可供选择：

* 可以返回指向对象的应用、指向对象的 const 引用或 const 对象。

#### 12.4.1 返回指向 const 对象的引用

* 使用 const 引用原因：提高效率。

* 一下两种方法均可行：

  * ```c++
    Vector Max(const Vector & v1, const Vector & v2)
    {
        if (v1.magval() > v2.magval())
            return v1;
        else
            return v2;
    }
    ```

    * 《返回对象方法》

  * ```c++
    const Vector & Max(const Vector & v1, const Vector & v2)
    {
        if (v1.magval() > v2.magval())
            return v1;
        else
            return v2;
    }
    ```

    * 《返回引用方法》

  * 《返回对象方法》将复制构造函数，而《返回引用方法》不会。

    * 因此第二个版本效率更高。

  * 引用指向的对象应该在调用函数执行时存在。

  * v1，v2都被声明为const引用，因此返回类型必须为const这样才匹配。

#### 12.4.2 返回指向非 const 对象的引用

常见的返回非 const 对象有两种情形：（前者为了提高效率，后者必须这样做）

* 1、重载赋值运算符：

  * operator=()的返回值用于连续赋值

    * ```c++
      String s1("Good Stuff");
      String s2, s3;
      s3 = s2 = s1;
      ```

    * 返回 String 对象或 String 对象的引用都是可行的，但与Vector示例中一样，通过使用引用，可避免该函数调用 String 的复制构造函数来创建一个新的 String 对象。

    * 该例子返回类型不是 const ，因为方法 operator=()返回一个指向 s2 的引用，可以对其进行修改。

* 2、重载与cout一起使用的<<运算符

  * ```c++
    String s1("Good stuff");
    cout << s1 << "is coming!";
    ```

  * operator<<(cout, s1)的返回值成为一个用于显式字符串"is coming!"的对象。返回类型必须是 ostream&，而不能仅仅是 ostream。

  * 如果使用返回类型 ostream 见P450。

#### 12.4.3 返回对象

如果被返回的对象是被调用函数中的**局部变量**，则不应按引用方式返回它，因为在被调用函数执行完毕时，局部对象将调用其析构函数。因此，当控制权回到调用函数时，引用指向的对象将不再存在。在这种情况下，应返回对象而不是引用。通常，被重载的算术运算符属于这一类。

* 返回值不能是指向在调用函数中已经存在的对象的引用。

* 见P450，operator+( )中计算得到的两个矢量的和被存储在一个新的临时对象中，该函数也不应返回指向该临时对象的应用，而应该返回实际的 Vector 对象，而不是引用：

  * ```c++
    Vector Vector::operator+(const Vector & b) const
    {
        return Vector(x + b.x, y + b.y);
    }
    ```

  * 在这种情况下，存在调用复制构造函数来创建被返回的对象的开销，然而这是无法避免的。

* 因此，上述例子返回语句引发的对复制构造函数的隐式调用创建一个调用程序能够访问的对象。

#### 12.4.4 返回 const 对象

见P451：

* 总之，如果方法或函数要返回局部对象，则应返回对象，而不是指向对象的引用。
  * 在这种情况下，将使用复制构造函数来生成返回的对象。

* 如果方法或函数要返回一个没有公有复制构造函数的类(如 ostream 类)的对象，它必须返回一个指向这种对象的引用。
* 最后，有些方法和函数(如重载的赋值运算符)可以返回对象，也可以返回指向对象的引用，在这种情况下，应首选引用，因为其效率更高。

### 12.5 使用指向对象的指针

程序清单12.6使用数组索引值来跟踪最短的字符串和按字母顺序排在最前面的字符串。

另一种方法使用指针指向这些类别的开始位置。程序清单12.7使用两个指向 String 的指针实现了这种方法。

最初，shortest 指针指向数组中的第一个对象。每当程序找到比指向字符串更短的对象时，就把 shortest 重新设置为指向该对象。同样，first 指针跟踪按字母顺序排在最前面的字符串。（这些指针并不要求使用 new 来分配内存，因为这两个指针是指向已有的对象）

此外，还使用一个指针来跟踪新对象：

```c++
String * favorite = new String(sayings[choice]);
```

指针 favorite 指向 new 创建的未被命名对象。这意味着使用对象  saying[choice] 来初始化新的 String 对象，这将调用复制构造函数，因为复制构造函数（const String &）的参数类型与初始化值（saying[choice])匹配。

* 示例：

  * ```c++
    // ch12_07_sayings2.cpp -- using pointers to objects
    // compile with ch12_07_sayings2.cpp
    #include <iostream>
    #include <cstdlib>
    #include <ctime>
    #include "ch12_04_string1.h"
    
    const int ArSize = 10;
    const int MaxLen = 81;
    
    int main()
    {
    	using namespace std;
    
    	String name;
    	cout << "Hi, what's your name?\n>> ";
    	cin >> name;
    
    	cout << name << ", please enter up to " << ArSize
    		<< " short sayings <empty line to quit>:\n";
    	String sayings[ArSize];
    	char temp[MaxLen];
    	int i;
    	for (i = 0; i < ArSize; i++)
    	{
    		cout << i + 1 << ": ";
    		cin.get(temp, MaxLen);
    		while (cin && cin.get() != '\n')
    			continue;
    		if (!cin || temp[0] == '\0')	//empty line?
    			break;
    		else
    			sayings[i] = temp;
    	}
    	int total = i;
    
    	if (total > 0)
    	{
    		cout << "Here are your sayings:\n";
    		for (i = 0; i < total; i++)
    			cout << sayings[i] << endl;
    	// use pointers to keep track of shortest, first strings
    		String* shortest = &sayings[0];
    		String* first = &sayings[0];
    		for (i = 1; i < total; i++)
    		{
    			if (sayings[i].length() < shortest->length())
    				shortest = &sayings[i];
    			if (sayings[i] < *first)
    				first = &sayings[i];
    		}
    		cout << "Shortest saying:\n" << *shortest << endl;
    		cout << "First alphabetically:\n" << *first << endl;
    		srand(time(0));
    		int choice = rand() % total; // pick index at random
    	// use new to create, initialize new String object
    		String* favorite = new String(sayings[choice]);
    		cout << "My favorite saying:\n" << *favorite << endl;
    		delete favorite;
    	}
    	else
    		cout << "Not much to say, eh?\n";
    	cout << "No input! Bye.\n";
    	return 0;
    
    }
    ```

* 结果：

  * ```c++
    Hi, what's your name?
    >> Kirt Rood
    Kirt Rood, please enter up to 10 short sayings <empty line to quit>:
    1: a friend in need is a friend indeed
    2: neither a borrower nor a lender be
    3: a stich in times saves nine
    4: a niche in time saves stine
    5: it takes a crook to catch a crook
    6: cold hands, warm heart
    7:
    Here are your sayings:
    a friend in need is a friend indeed
    neither a borrower nor a lender be
    a stich in times saves nine
    a niche in time saves stine
    it takes a crook to catch a crook
    cold hands, warm heart
    Shortest saying:
    cold hands, warm heart
    First alphabetically:
    a friend in need is a friend indeed
    My favorite saying:
    a stich in times saves nine
    No input! Bye.
    ```

  * 使用new初始化对象：

    * 如果Class_name是类，value的类型为Type_name，则：

      * ```c++
        Class_name * pclass = new Class_name(value);
        ```

    * 将调用如下构造函数：

      * ```c++
        Class_name(Type_name);
        ```

    * 这里可能还有一些琐碎的转换：

      * ```c++
        Class_name(const Type_name &);
        ```

    * 另外，如果不存在二义性，则将发生由原型匹配导致的转换（如 int 到 double）。下面初始化方式将调用默认构造函数：

      * ```c++
        Class_name * ptr = new Class_name;
        ```

#### 12.5.1 再谈 new 和 delete

上述工程在两个层次上使用了 new 和 delete：

* 1、使用 new 为创建的每一个对象的名称字符串分配存储空间，这是在构造函数中进行的，因此析构函数使用 delete 来释放这些内存。因为字符串是一个字符数组，所以析构函数使用的是带中括号的 delete。这样，当对象被释放时，用于存储字符串的内容将被自动释放。

  * ```c++
    // class methods
    // construct StringBad from C string
    String::String(const char* s)
    {
    	len = std::strlen(s);
    	str = new char[len + 1];
    	std::strcpy(str, s);
    	num_strings++;
    }
    
    String::String()
    {
    	len = 4;
    	str = new char[1];
    	str[0] = '\0';
    	num_strings++;
    }
    
    String::String(const String& st)
    {
    	num_strings++;
    	len = st.len;
    	str = new char[len + 1];
    	std::strcpy(str, st.str);
    }
    
    String::~String()
    {
    	--num_strings;
    	delete[] str;
    }
    ```

* 2、使用 new 来为整个对象分配内存：

  * ```c++
    String* favorite = new String(sayings[choice]);
    cout << "My favorite saying:\n" << *favorite << endl;
    delete favorite;
    ```

  * 这不是为要存储的字符串分配内存，而是为对象分配内存；也就是说，为保存字符串地址的 str 指针和 len 成员分配内存（程序并没有给 num_string 成员分配内存，这是因为 num_string 成员是静态成员，它独立于对象被保存）。

  * 创建对象将调用构造函数，后者分配用于保存字符串的内存，并将字符串的地址赋给 str。

  * 然后当程序不再需要该对象时，使用 delete删除它。对象是单个的，因此程序使用不带中括号的 delete。

  * 与前面相同，这将只释放用于保存 str 指针和 len 成员的空间，并不释放 str 指向的内存，而该任务将由析构函数完成。

  * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/2475707c-f450-4cea-8c5e-db6f4cca9f73)


* 析构函数将被调用的情况，见P454

  * 如果对象是动态变量，则当执行完定义该对象的程序块时，将调用该对象的析构函数。
  * 如果对象时静态变量，则在程序结束时将调用对象的析构函数。
  * 如果对象是 new 创建的，则仅当您显式使用 delete 删除对象时，其析构函数才会被调用。

#### 12.5.2 指针和对象小结

使用对象指针需注意几点：

![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/cce5f65a-45e8-43c0-ae7c-8705edb1154a)

* 使用常规表示法来声明指向对象的指针：

  * ```c++
    String * glamour;
    ```

* 可以将指针初始化为指向已有的对象：

  * ```c++
    String * first = &sayings[0];
    ```

* 可以使用 new 来初始化指针，这将创建一个新的对象：

  * ```c++
    String * favorite = new String(sayings[choice]);
    ```

* 对类使用 new 将调用相应的类构造函数来初始化新创建的对象：

  * ```c++
    // invokes default constructor
    String * gleep = new String;
    // invokes the String(const char *)constructor
    String * glop = new String("my my my");
    // invokes the String(const String &)constructor
    String * favorite = new String(sayings[choice]);
    ```

  * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/25c78551-7e65-4f13-9f23-fc2c2c3ee8e1)

* 可以使用->运算符通过指针访问类对象：

  * ```c++
    if (sayings[i].length() < shortest->length());
    ```

* 可以对对象指针应用解除引用运算符（*）来获得对象：

  * ```c++
    if (sayings[i] < *first)
        first = &sayings[i];
    ```

#### 12.5.3 再谈定位 new 运算符

定位 new 运算符能够让您在分配内存时能够指定内存位置，在定位 new 运算符用于对象时的情况有些不同。

* 示例：

  * ```c++
    // ch12_08_placenew1.cpp -- new, placement new, no delete
    #include <iostream>
    #include <string>
    #include <new>
    using namespace std;
    const int BUF = 512;
    
    class JustTesting
    {
    private:
    	string words;
    	int number;
    public:
    	JustTesting(const string& s = "Just Testing", int n = 0)
    	{
    		words = s;
    		number = n;
    		cout << words << " constructed\n";
    	}
    	~JustTesting() { cout << words << " destroyed\n"; }
    	void Show() const { cout << words << ", " << number << endl; }
    };
    
    int main()
    {
    	char* buffer = new char[BUF];
    
    	JustTesting* pc1, * pc2;
    
    	pc1 = new (buffer) JustTesting;		// place object in buffer
    	pc2 = new JustTesting("Heap1", 20);	// place object on heap
    
    	cout << "Memory block addresses:\n" << "buffer: "
    		<< (void*)buffer << "     heap: " << pc2 << endl;
    	cout << "Memory contents:\n";
    	cout << pc1 << ": ";
    	pc1->Show();
    	cout << pc2 << ": ";
    	pc2->Show();
    
    	JustTesting* pc3, * pc4;
    	pc3 = new (buffer) JustTesting("Bad Idea", 6);
    	pc4 = new JustTesting("Heap2", 10);
    
    	cout << "Memory contents:\n";
    	cout << pc3 << ": ";
    	pc3->Show();
    	cout << pc4 << ": ";
    	pc4->Show();
    
    	delete pc2;
    	delete pc4;
    	delete[] buffer;
    	cout << "Done\n";
    	return 0;
    }
    ```

* 结果：

  * ```c++
    Just Testing constructed
    Heap1 constructed
    Memory block addresses:
    buffer: 008B29D8     heap: 008ACF18
    Memory contents:
    008B29D8: Just Testing, 0
    008ACF18: Heap1, 20
    Bad Idea constructed
    Heap2 constructed
    Memory contents:
    008B29D8: Bad Idea, 6
    008AC4E8: Heap2, 10
    Heap1 destroyed
    Heap2 destroyed
    Done
    ```

  * 该程序使用 new 运算符创建了一个512字节的内存缓冲区，然后使用 new 运算符在堆中创建两个JustTesting对象，并使用定位 new 运算符在内存缓冲区中创建两个 JustTesting 对象。最后，它使用 delete 来释放使用 new 分配的内存。

  * 两个问题：

    * 1、在创建第二个对象时，定位 new 运算符使用一个新对象来覆盖用于第一个对象的内存单元。如果类动态地为其成员分配内存，这将引发问题。

      * 解决办法：要使用不同的内存单元，需要提供两个位于缓冲区不同的地址，并确保这两个内存单元不重叠：

        * ```c++
          pc1 = new (buffer) JustTesting;
          pc3 = new (buffer + sizeof (JustTesting)) JustTesting("Better Idea", 6);
          ```

        * 其中pc3相对于pc1的偏移量为JustTesting对象的大小。

    * 2、将 delete 用于 pc2和pc4时，将自动调用为pc2和pc4指向地对象调用析构函数；然而，将delete[] 用于buffer时，不会为使用定位 new 运算符创建地对象调用析构函数。

      * 解决办法：如果使用定位 new 运算符来为对象分配内存，必须确保其析构函数被调用。

      * ```c++
        //对于在堆中创建的对象，可以这样
        delete pc2;
        //但不能这样做
        delete pc1;
        delete pc3;
        //因为delete可与常规new运算符配合使用，但不能与定位new运算符配合使用。
        ```

      * delete [] buffer 释放使用常规 new 运算符分配的整个内存块，但它没有为定位 new 运算符在该内存块中创建的对象调用析构函数，见P458。

        * 解决方案：显式地使用定位 new 运算符创建的对象调用析构函数：

          * ```c++
            pc3->~JustTesting();
            pc1->~JustTesting();
            ```

          * 需要注意的一点是正确的删除顺序。对于使用定位 new 运算符创建的对象，应以与创建顺序相反的顺序进行删除。原因在于，晚创建的对象可能依赖于早创建的对象。另外，又当所有对象都被销毁后，才能释放用于存储这些对象的缓冲区。

* 改进后示例：

  * ```c++
    // ch12_09_placenew2.cpp -- new, placement new, no delete
    #include <iostream>
    #include <string>
    #include <new>
    using namespace std;
    const int BUF = 512;
    
    class JustTesting
    {
    private:
    	string words;
    	int number;
    public:
    	JustTesting(const string& s = "Just Testing", int n = 0)
    	{
    		words = s;
    		number = n;
    		cout << words << " constructed\n";
    	}
    	~JustTesting() { cout << words << " destroyed\n"; }
    	void Show() const { cout << words << ", " << number << endl; }
    };
    
    int main()
    {
    	char* buffer = new char[BUF];
    
    	JustTesting* pc1, * pc2;
    
    	pc1 = new (buffer) JustTesting;		// place object in buffer
    	pc2 = new JustTesting("Heap1", 20);	// place object on heap
    
    	cout << "Memory block addresses:\n" << "buffer: "
    		<< (void*)buffer << "     heap: " << pc2 << endl;
    	cout << "Memory contents:\n";
    	cout << pc1 << ": ";
    	pc1->Show();
    	cout << pc2 << ": ";
    	pc2->Show();
    
    	JustTesting* pc3, * pc4;
    // fix placement new location
    	pc3 = new (buffer + sizeof (JustTesting)) JustTesting("Better Idea", 6);
    	pc4 = new JustTesting("Heap2", 10);
    
    	cout << "Memory contents:\n";
    	cout << pc3 << ": ";
    	pc3->Show();
    	cout << pc4 << ": ";
    	pc4->Show();
    
    	delete pc2;
    	delete pc4;
    // explicitly destroy placement new objects
    	pc3->~JustTesting();
    	pc1->~JustTesting();
    	delete[] buffer;
    	cout << "Done\n";
    	return 0;
    }
    ```

* 结果：

  * ```c++
    Just Testing constructed
    Heap1 constructed
    Memory block addresses:
    buffer: 00F22C10     heap: 00F1CF18
    Memory contents:
    00F22C10: Just Testing, 0
    00F1CF18: Heap1, 20
    Better Idea constructed
    Heap2 constructed
    Memory contents:
    00F22C30: Better Idea, 6
    00F1C4E8: Heap2, 10
    Heap1 destroyed
    Heap2 destroyed
    Better Idea destroyed
    Just Testing destroyed
    Done
    ```



### 12.6 复习各种技术

#### 12.6.1 重载<<运算符

要重新定义<<运算符，以便将它和cout一起用来显示对象的内容，则需要定义下面的友元运算符函数：

* ```c++
  ostream & operator<<(ostream & os, const c_name & obj)
  {
      os << ...;
      return os;
  }
  ```

* 其中 c_name 是类名。如果该类提供了能够返回所需内容的公有方法，则可在运算符函数中使用这些法，这样便不用将它们设置为友元函数了。

#### 12.6.2 转换函数

要将单个值转换为类类型，需要创建原型如下的类构造函数：

* ```c++
  c_name(type_name value);
  ```

* c_name：类名，type_name：要转换的类型的名称

要将类转换为其他类型，需要创建原型如下的类成员函数：

* ```c++
  operator type_name();
  ```

* 虽然该函数没有声明返回类型，但应返回所需类型的值。

* 使用转换函数时要小心。可以在声明构造函数时使用关键字 explicit，以防止它被用于隐式转换。

#### 12.6.3 其构造函数使用new的类

如果类使用new运算符来分配类成员指向的内存，在设计时应采取一些预防措施：

* 对于指向的内存是由 new 分配的所有类成员，都应在类的析构函数中对其使用 delete，该运算将释放分配的内存。

* 如果析构函数通过对指针类成员使用 delete 来释放内存，则每个构造函数都应当使用 new 来初化指针，或将它设置为空指针。

* 构造函数中要么使用new[]，要么使用new，而不能混用。如果构造函数使用的是 new[]]，则析函数应使用 delete[]]；如果构造函数使用的是new，则析构函数应使用 delete。

* 应定义一个分配内存(而不是将指针指向已有内存)的复制构造函数。这样程序将能够将类对初始化为另一个类对象。这种构造函数的原型通常如下：

  * ```C++
    className(const className &)
    ```

* 应定义一个重载赋值运算符的类成员函数，其函数定义如下(其中 c_pinter 是 c_name 的类成员，类型为指向 type_name 的指针)。下面的示例假设使用 new[] 来初始化变量 c_pointer：

  * ```c++
    c_name & c_name::operator=(const c_name & cn)
    {
        if (this == & cn)
            return *this;
        delete [] c_pointer;
        c_pointer = new type_name[size];
        ...
        return *this;
    }
    ```



### 12.7 队列模拟

* 队列：可以存储有序的项目序列。
  * 新项目被添加在队尾，并可以删除队首的项目。
  * 队列优点像栈，但栈在同一端进行添加和删除。
  * 因此栈：后进先出（LIFO，last-in，first-out），队列先进先出（FIFO，first-in，first-out）
  * 概念上看，队列好比是收款台或ATM前面排的队
* 队列模拟方案：（队列中的项目是顾客，Heather银行的代表介绍见P461，设计一个表示顾客的类；编写一个程序来模拟顾客和队列之间的交互）
  * ![image](https://github.com/CoderSuHang/Cpp-Primer-Plus-Notes/assets/104765251/37b79b8b-63cf-4d55-b64a-59e2ce701248)

#### 12.7.1 队列类

首先设计一个Queue类，队列特征如下：

* 队列存储有序的项目序列；
* 队列所能容纳的项目数有一定的限制；
* 应当能够创建空队列；
* 应当能够检查队列是否为空；
* 应当能够检查队列是否是满的；
* 应当能够在队尾添加项目；
* 应当能够从队首删除项目；
* 应当能够确定队列中的项目数。

设计类是，需要开发共有接口和私有接口：

**1、Queue类的接口**

* Queue类的共有接口：

  * ``` c++
    class Queue
    {
        enum {Q_SIZE = 10};
     private:
     // private representation to be developed later
     public:
        Queue(int qs = Q_SIZE);
        ~Queue();
        bool isempty() const;
        bool isfull() const;
        int queuecount() const;
        bool enqueue(const Item &item);
        bool dequeue(Item &item);
    };
    ```

  * 构造函数创建一个空队列。默认情况下，队列最多可存储 10 个项目，但是可以用显式初始化参数覆盖该默认值：

    * ```c++
      Queue line1;
      Queue line2(20);
      ```

  * 使用队列时，可以使用typedef来定义Item。

**2、Queue类的实现**

确定接口后，便可以实现它。

* 首先，需要确定如何表示队列数据：

  * 一种方法是使用new动态分配一个数组，它包含所需的元素数。然而，对于队列操作来说，数组并不合适。见P462，数组实现循环变化较难。

  * 另一种方法是使用链表，能够很好地满足队列的要求。

    * 链表由节点序列构成，每一个节点中都包含要保存到链表中的信息以及一个指向下一个节点的指针。

    * 对于这里的队列来说，数据部分都是一个一个Item类型的值，因此可以使用下面的结构来表示节点：

      * ```c++
        Struct Node
        {
            Item item;
            struct Node * next;
        };
        ```

    * 如下图所示是一个单向链表，因为每个节点都只包含一个指向其他节点的指针。

      * ![image-20231214170101984](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231214170101984.png)
      * 通常，链表最后一个节点中的指针被设置为NULL或0，以指出后面没有节点了。
      * 见P462。如何跟踪链表节点：
        * ![image-20231214170528677](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231214170528677.png)

* 其次对类的私有部分进行声明与下面类似：

  * ```c++
    class Queue
    {
    private:
    // class scope definitions
        // Node is a nested structure definition local to this class
        struct Node { Item item; struct Node * next; };
        enum { Q_SIZE = 10 };
    // private class members
        Node * front;
        Node * rear;
        int items;
        const int qsize;
        ...
    public:
        ...
    };
    ```

  * 上述声明使用了 C++ 的一项特性：在类中套结构或类声明。

    * 通过将 Node 声明放在 Oueue 类中可以使其作用域为整个类。
    * 也就是说，Node 是这样一种类型：可以使用它来声明类成员，也可以将它作为类方法中的类型名称，但只能在类中使用。
    * 这样，就不必担心该 Node 声明与某些全局声明或其他类中声明的 Node 发生冲突。有些较老的编译器不支持嵌套的结构和类，如果您的编译器是这样的，则必须将 Node结构定义为全局的，将其作用域设置为整个文件。
    * 详情见P463。

**3、类方法**

* 类构造函数应提供类成员的值。而在本例中，队列最初是空的，因此队首和队尾指针都设置为NULL或0或nullptr，并将items设置为0。另外，还应将队列的最大长度qsize设置为构造函数参数qs的值。（P464有无法正常运行案例）

  * 对于const数据成员，必须在执行到构造函数体之前，即创建对象时进行初始化：

    * 成员初始化列表：由逗号分割的初始化列表组成（前面带括号）。它位于参数列表的右括号之后、函数体左括号之前。

      * 如果数据成员名称为mdata，并需要将它初始化为val，则初始化器为mdata(val)：

      * ```c++
        Queue::Queue(int qs) : qsize(qs)
        {
            front = rear = NULL;
            items = 0;
        }
        ```

    * 通常，初值可以是常量或构造函数的参数列表中的参数。这种方法并不限于初始化常量，因此可将Queue构造函数写成如下：

      * ```c++
        Queue::Queue(int qs) : qsize(qs), front(NULL), rear(NULL), items(0)
        {
            
        }
        ```

      * ❗只有构造函数可以使用这种初始化列表语法。

        * 对于const类成员，必须使用这种语法。

        * 对于被声明为引用的类成员，也必须使用这种语法。

          * ```c++
            class Agency {...};
            class Agent
            {
            private:
                Agency & belong;
                ...
            };
            Agent::Agent(Agency & a) : belong(a) {...}
            ```

          * 这是因为引用与const数据类似，只能在被创建时进行初始化。

    * 成员初始化列表语法详情见P464。

  * C++的类内初始化：

    * 允许以更直观的方式进行初始化，与在构造函数中使用**成员初始化列表**等价：

      * ```c++
        class Classy
        {
            int mem1 = 10;
            const int mem2 = 20;
            //...
        };
        //等价于
        Classy::Classy() : mem1(10), mem2(20) {...}
        ```

* isempty()、isfull()和queuecount()的代码都非常简单：

  * 如果items为0，则队列为空；如果items等于qsize，则队列为满。因此要知道队列中的项目数，返回items的值即可。

* 将项目添加到队尾（入队）的方法：

  * ```c++
    bool Queue::enqueue(const Item & item)
    {
        if (isfull())
            return false;
        Node * add = new Node;	// create node
    // no failure, new throws std::bad_alloc excption
        add->item = item;
        add->next = NULL;
        items++;
        if (front == NULL)
            front = add;
        else
            rear->next = add;
        rear = add;
        return ture;
    }
    ```

  * ![image-20231214194334553](C:\Users\10482\AppData\Roaming\Typora\typora-user-images\image-20231214194334553.png)

#### 12.7.2 Customer 类

#### 12.7.3 ATM模拟
